/*! ess - v - 2017-06-30 */
function accrualBarDirective(appProps) {
    return {
        scope: {
            accruals: "=",
            loading: "="
        },
        templateUrl: appProps.ctxPath + "/template/time/accrual/accrual-bar"
    };
}

function accrualDetailDirective(appProps, modals, accrualUtils) {
    return {
        templateUrl: appProps.ctxPath + "/template/time/accrual/accrual-details",
        link: function($scope, $elem, $attrs) {
            $scope.accruals = modals.params().accruals, $scope.$watchCollection("accruals", function() {
                $scope.accruals && ($scope.reportUrl = accrualUtils.getAccrualReportURL($scope.accruals));
            }), $scope.close = modals.resolve;
        }
    };
}

function accrualHistoryDirective($timeout, $rootScope, appProps, modals, AccrualHistoryApi, EmpInfoApi, ActiveYearsTimeRecordsApi) {
    return {
        scope: {
            empSupInfo: "=?"
        },
        templateUrl: appProps.ctxPath + "/template/time/accrual/history-directive",
        link: function($scope, $elem, $attrs) {
            function getEmpInfo() {
                if ($scope.empId && $scope.isUser()) {
                    var params = {
                        empId: $scope.empId,
                        detail: !0
                    };
                    $scope.request.empInfo = !0, EmpInfoApi.get(params, function(response) {
                        var empInfo = response.employee;
                        $scope.empInfo = empInfo, $scope.isTe = "TE" === empInfo.payType;
                    }, function(errorResponse) {
                        modals.open("500", errorResponse);
                    }).$promise.finally(function() {
                        $scope.request.empInfo = !1;
                    });
                }
            }
            function getEmpActiveYears() {
                if ($scope.empId) {
                    $scope.selectedYear = null;
                    var params = {
                        empId: $scope.empId
                    };
                    $scope.request.empActiveYears = !0, ActiveYearsTimeRecordsApi.get(params, function(resp) {
                        if ($scope.activeYears = resp.years.reverse(), !$scope.isUser()) {
                            var startDateYear = moment($scope.empSupInfo.effectiveStartDate || 0).year(), endDateYear = moment($scope.empSupInfo.effectiveEndDate || void 0).year();
                            $scope.activeYears = $scope.activeYears.filter(function(year) {
                                return year >= startDateYear && year <= endDateYear;
                            });
                        }
                        $scope.selectedYear = $scope.activeYears.length > 0 && $scope.activeYears[0];
                    }, function(resp) {
                        modals.open("500", {
                            details: resp
                        });
                    }).$promise.finally(function() {
                        $scope.request.empActiveYears = !1;
                    });
                }
            }
            function getAccSummaries() {
                var year = $scope.selectedYear;
                if (year && !$scope.accSummaries[year]) {
                    var fromDate = moment([ year, 0, 1 ]), toDate = moment([ year + 1, 0, 1 ]);
                    if (!$scope.isUser()) {
                        var startDateMoment = moment($scope.empSupInfo.effectiveStartDate || 0), endDateMoment = moment($scope.empSupInfo.effectiveEndDate || "3000-01-01");
                        fromDate = moment.max(fromDate, startDateMoment), toDate = moment.min(toDate, endDateMoment);
                    }
                    var params = {
                        empId: $scope.empId,
                        fromDate: fromDate.format("YYYY-MM-DD"),
                        toDate: toDate.format("YYYY-MM-DD")
                    };
                    $scope.request.accSummaries = !0, AccrualHistoryApi.get(params, function(resp) {
                        $scope.error = null, $scope.accSummaries[year] = resp.result.filter(function(acc) {
                            return !acc.computed || acc.submitted;
                        }).reverse();
                    }, function(resp) {
                        modals.open("500", {
                            details: resp
                        }), $scope.error = {
                            title: "Could not retrieve accrual information.",
                            message: "If you are eligible for accruals please try again later."
                        };
                    }).$promise.finally(function() {
                        $scope.request.accSummaries = !1;
                    });
                }
            }
            function setEmpId() {
                $scope.empSupInfo && $scope.empSupInfo.empId ? $scope.empId = $scope.empSupInfo.empId : $scope.empId = appProps.user.employeeId;
            }
            function clearAccSummaries() {
                $scope.accSummaries = {};
            }
            function reflowTable(count) {
                count > 20 || !$scope.accSummaries[$scope.selectedYear] || (count = isNaN(count) ? 0 : count, 
                $(".detail-acc-history-table").floatThead("reflow"), $timeout(function() {
                    reflowTable(count + 1);
                }, 5));
            }
            function enableFloatThead() {
                $scope.floatTheadEnabled = !0;
            }
            function disableFloatThead() {
                $scope.floatTheadEnabled = !1;
            }
            $scope.accSummaries = {}, $scope.activeYears = [], $scope.timeRecords = [], $scope.selectedYear = null, 
            $scope.empInfo = {}, $scope.isTe = !1, $scope.error = null, $scope.request = {
                empInfo: !1,
                empActiveYears: !1,
                accSummaries: !1
            }, $scope.floatTheadOpts = {
                scrollingTop: 47,
                useAbsolutePositioning: !1
            }, $scope.floatTheadEnabled = !0, $scope.hideTitle = "true" === $attrs.hideTitle, 
            $scope.$watchCollection("empSupInfo", setEmpId), $scope.$watchCollection("empSupInfo", getEmpInfo), 
            $scope.$watchCollection("empSupInfo", getEmpActiveYears), $scope.$watchCollection("empSupInfo", clearAccSummaries), 
            $scope.$watch("selectedYear", getAccSummaries), $rootScope.$on("reflowEvent", reflowTable), 
            $scope.$on("beforePrint", disableFloatThead), $scope.$on("afterPrint", enableFloatThead), 
            $scope.isUser = function() {
                return $scope.empId === appProps.user.employeeId;
            }, $scope.isLoading = function() {
                for (var dataType in $scope.request) if ($scope.request.hasOwnProperty(dataType) && $scope.request[dataType]) return !0;
                return !1;
            }, $scope.isEmpLoading = function() {
                return $scope.request.empInfo || $scope.request.empActiveYears;
            }, $scope.viewDetails = function(accrualRecord) {
                modals.open("accrual-details", {
                    accruals: accrualRecord
                }, !0);
            }, $scope.$watchCollection("accSummaries[selectedYear]", reflowTable);
        }
    };
}

function accrualProjectionDirective($timeout, $rootScope, appProps, AccrualHistoryApi, EmpInfoApi, modals, accrualUtils) {
    return {
        scope: {
            empSupInfo: "=?"
        },
        templateUrl: appProps.ctxPath + "/template/time/accrual/projections-directive",
        link: function($scope, $elem, $attrs) {
            function getAccSummaries() {
                if ($scope.empId) {
                    var year = moment().year(), fromDate = moment([ year, 0, 1 ]).subtract(6, "months"), toDate = moment([ year + 1, 0, 1 ]);
                    if (!$scope.isUser()) {
                        var startDateMoment = moment($scope.empSupInfo.effectiveStartDate || 0), endDateMoment = moment($scope.empSupInfo.supEndDate || "3000-01-01");
                        fromDate = moment.max(fromDate, startDateMoment), toDate = moment.min(toDate, endDateMoment);
                    }
                    var params = {
                        empId: $scope.empId,
                        fromDate: fromDate.format("YYYY-MM-DD"),
                        toDate: toDate.format("YYYY-MM-DD")
                    };
                    $scope.error = null, $scope.request.accSummaries = !0, AccrualHistoryApi.get(params, function(resp) {
                        $scope.accSummaries = resp.result.filter(function(acc) {
                            return !acc.computed || acc.submitted;
                        }).reverse(), $scope.projections = resp.result.filter(isValidProjection).map(initializeProjection);
                    }, function(resp) {
                        modals.open("500", {
                            details: resp
                        }), $scope.error = {
                            title: "Could not retrieve accrual information.",
                            message: "If you are eligible for accruals please try again later."
                        };
                    }).$promise.finally(function() {
                        $scope.request.accSummaries = !1;
                    });
                }
            }
            function getEmpInfo() {
                if ($scope.empId && $scope.isUser()) {
                    var params = {
                        empId: $scope.empId,
                        detail: !0
                    };
                    $scope.request.empInfo = !0, EmpInfoApi.get(params, function(response) {
                        var empInfo = response.employee;
                        $scope.empInfo = empInfo, $scope.isTe = "TE" === empInfo.payType;
                    }, function(errorResponse) {
                        modals.open("500", errorResponse);
                    }).$promise.finally(function() {
                        $scope.request.empInfo = !1;
                    });
                }
            }
            function setEmpId() {
                $scope.empSupInfo && $scope.empSupInfo.empId ? $scope.empId = $scope.empSupInfo.empId : $scope.empId = appProps.user.employeeId;
            }
            function isValidProjection(acc) {
                return acc.computed && !acc.submitted && "TE" !== acc.empState.payType && acc.empState.employeeActive;
            }
            function initializeProjection(projection) {
                return deltaFields.forEach(function(fieldName) {
                    0 === projection[fieldName] && (projection[fieldName] = null);
                }), projection.changed = {}, projection.maxHours = 12 * projection.payPeriod.numDays, 
                projection.validation = getCleanValidation(), projection.valid = !0, projection;
            }
            function recalculateProjectionTotals() {
                for (var accSummaries = $scope.accSummaries, projections = $scope.projections, baseRec = accSummaries.length > 0 ? accSummaries[0] : null, multiYear = !1, accState = getInitialAccState(baseRec), i = 0; i < projections.length; i++) {
                    var rec = projections[i], lastRec = 0 === i ? baseRec : projections[i - 1];
                    multiYear && (rec.vacationBanked = lastRec.vacationBanked, rec.sickBanked = lastRec.sickBanked), 
                    lastRec && accrualUtils.isFirstRecordOfYear(rec) && (multiYear = !0, applyRollover(rec, lastRec, accState)), 
                    updateAccrualState(rec, accState), setRecordUsedHours(rec, accState), calculateAvailableHours(rec), 
                    validateRecord(rec, accState);
                }
            }
            function getCleanValidation() {
                return {
                    per: !0,
                    vac: !0,
                    sick: !0
                };
            }
            function getInitialAccState(baseRec) {
                return baseRec = baseRec || {}, {
                    per: baseRec.personalUsed || 0,
                    vac: baseRec.vacationUsed || 0,
                    sickEmp: baseRec.sickEmpUsed || 0,
                    sickFam: baseRec.sickFamUsed || 0,
                    validation: getCleanValidation()
                };
            }
            function applyRollover(record, lastRecord, accState) {
                record.vacationBanked = Math.min(lastRecord.vacationAvailable, maxVacationBanked), 
                record.sickBanked = Math.min(lastRecord.sickAvailable, maxSickBanked), accState.per = accState.vac = accState.sickEmp = accState.sickFam = 0;
            }
            function updateAccrualState(rec, accState) {
                accState.per += rec.biweekPersonalUsed || 0, accState.vac += rec.biweekVacationUsed || 0, 
                accState.sickEmp += rec.biweekSickEmpUsed || 0, accState.sickFam += rec.biweekSickFamUsed || 0;
            }
            function setRecordUsedHours(rec, accState) {
                rec.personalUsed = accState.per, rec.vacationUsed = accState.vac, rec.sickEmpUsed = accState.sickEmp, 
                rec.sickFamUsed = accState.sickFam, rec.holidayUsed = rec.holidayUsed || 0;
            }
            function calculateAvailableHours(rec) {
                rec.personalAvailable = rec.personalAccruedYtd - rec.personalUsed, rec.vacationAvailable = rec.vacationAccruedYtd + rec.vacationBanked - rec.vacationUsed, 
                rec.sickAvailable = rec.sickAccruedYtd + rec.sickBanked - rec.sickEmpUsed - rec.sickFamUsed;
            }
            function validateRecord(record, accState) {
                var validation = accState.validation;
                validation.per = validation.per && isPerValid(record), validation.vac = validation.vac && isVacValid(record), 
                validation.sick = validation.sick && isSickEmpValid(record) && isSickFamValid(record), 
                record.validation = angular.copy(validation), record.valid = validation.per && validation.vac && validation.sick;
            }
            function isPerValid(record) {
                return isValidValue(record.biweekPersonalUsed, record.personalAvailable);
            }
            function isVacValid(record) {
                return isValidValue(record.biweekVacationUsed, record.vacationAvailable);
            }
            function isSickEmpValid(record) {
                return isValidValue(record.biweekSickEmpUsed, record.sickAvailable);
            }
            function isSickFamValid(record) {
                return isValidValue(record.biweekSickFamUsed, record.sickAvailable);
            }
            function isValidValue(value, available) {
                return null === value || void 0 !== value && available >= 0 && value % .5 === 0;
            }
            function setChangedFlags(record, type) {
                for (var projections = $scope.projections, startIndex = projections.indexOf(record), i = startIndex; i < projections.length; i++) projections[i].changed[type] = !0;
                $timeout(resetChangedFlags);
            }
            function resetChangedFlags() {
                angular.forEach($scope.projections, function(record) {
                    record.changed = {};
                });
            }
            function reflowTable(count) {
                count > 20 || !$scope.accSummaries || 0 === $scope.accSummaries.length || (count = isNaN(count) ? 0 : count, 
                $(".detail-acc-history-table").floatThead("reflow"), $timeout(function() {
                    reflowTable(count + 1);
                }, 5));
            }
            function enableFloatThead() {
                $scope.floatTheadEnabled = !0;
            }
            function disableFloatThead() {
                $scope.floatTheadEnabled = !1;
            }
            var maxVacationBanked = 210, maxSickBanked = 1400;
            $scope.projections = [], $scope.accSummaries = [], $scope.selectedYear = null, $scope.empInfo = null, 
            $scope.isTe = !1, $scope.error = null, $scope.request = {
                empInfo: !1,
                accSummaries: !1
            }, $scope.floatTheadOpts = {
                scrollingTop: 47,
                useAbsolutePositioning: !1
            }, $scope.floatTheadEnabled = !0, $scope.hideTitle = "true" === $attrs.hideTitle, 
            $scope.$watchCollection("empSupInfo", setEmpId), $scope.$watch("empId", getEmpInfo), 
            $scope.$watch("empId", getAccSummaries), $rootScope.$on("reflowEvent", reflowTable), 
            $scope.$on("beforePrint", disableFloatThead), $scope.$on("afterPrint", enableFloatThead), 
            $scope.isUser = function() {
                return $scope.empId === appProps.user.employeeId;
            }, $scope.isLoading = function() {
                for (var dataType in $scope.request) if ($scope.request.hasOwnProperty(dataType) && $scope.request[dataType]) return !0;
                return !1;
            }, $scope.onAccUsageChange = function(accrualRecord, type) {
                recalculateProjectionTotals(), setChangedFlags(accrualRecord, type);
            }, $scope.viewDetails = function(accrualRecord) {
                accrualRecord.valid && modals.open("accrual-details", {
                    accruals: accrualRecord
                }, !0);
            }, $scope.isPerValid = isPerValid, $scope.isVacValid = isVacValid, $scope.isSickEmpValid = isSickEmpValid, 
            $scope.isSickFamValid = isSickFamValid;
            var deltaFields = [ "biweekPersonalUsed", "biweekVacationUsed", "biweekSickEmpUsed", "biweekSickFamUsed" ];
            $scope.$watchCollection("projections", reflowTable);
        }
    };
}

function accrualUtils() {
    function isFirstRecordOfYear(record) {
        var beginDate = moment(record.payPeriod.startDate);
        return 0 === beginDate.month() && 1 === beginDate.date();
    }
    function getAccrualReportURL(record) {
        var url = "http://nysasprd.senate.state.ny.us:7778/reports/rwservlet?report=PRBSTS23&cmdkey=tsuser&p_nuxrefem=" + record.empId + "&p_dtend=" + moment(record.payPeriod.endDate).format("DD-MMM-YYYY");
        return record.computed && (url = url + "&p_dtbegin=" + moment(record.payPeriod.startDate).format("DD-MMM-YYYY") + "&p_datafrom=AUTO&p_nubiwsicrate=" + record.sickRate + "&p_nubiwvacrate=" + record.vacationRate + "&p_nuemphrs=" + (record.biweekSickEmpUsed || 0) + "&p_nuemphrsacc=" + record.sickAccruedYtd + "&p_nuemphrsbsd=" + record.sickBanked + "&p_nuemphrsuse=" + record.sickEmpUsed + "&p_nufamhrs=" + (record.biweekSickFamUsed || 0) + "&p_nufamhrsuse=" + record.sickFamUsed + "&p_nuholhrs=" + record.biweekHolidayUsed + "&p_nuhrsexpect=" + record.serviceYtdExpected + "&p_nuperhrs=" + (record.biweekPersonalUsed || 0) + "&p_nuperhrsacc=" + record.personalAccruedYtd + "&p_nuperhrsuse=" + record.personalUsed + "&p_nutotalhrs=" + record.totalHoursYtd + "&p_nutothrslast=0&p_nutrvhrs=" + record.biweekTravelUsed + "&p_nuvachrs=" + (record.biweekVacationUsed || 0) + "&p_nuvachrsacc=" + record.vacationAccruedYtd + "&p_nuvachrsbsd=" + record.vacationBanked + "&p_nuvachrsuse=" + record.vacationUsed + "&p_nuworkhrs=00" + (record.submitted ? "" : "&p_proj=Y")), 
        url;
    }
    return {
        isFirstRecordOfYear: isFirstRecordOfYear,
        getAccrualReportURL: getAccrualReportURL
    };
}

function allowanceBarDirective(appProps, allowanceUtils) {
    return {
        scope: {
            allowance: "=",
            tempWorkHours: "=?",
            loading: "=?"
        },
        templateUrl: appProps.ctxPath + "/template/time/allowance/allowance-bar",
        link: function($scope, $elem, $attrs) {
            var submitted = "true" === $attrs.submitted;
            $scope.getAvailableHours = function() {
                var hours = submitted ? 0 : $scope.tempWorkHours || 0;
                return allowanceUtils.getAvailableHours($scope.allowance, hours);
            }, $scope.showRecordHours = function() {
                return angular.isNumber($scope.tempWorkHours);
            };
        }
    };
}

function allowanceStatusDirective(appProps, modals, allowanceApi, allowanceUtils) {
    return {
        scope: {
            empSupInfo: "=?"
        },
        templateUrl: appProps.ctxPath + "/template/time/allowance/allowance-status-directive",
        link: function($scope, $elem, $attrs) {
            function getAllowance() {
                function onSuccess(resp) {
                    var results = resp.result || [];
                    if (1 !== results.length) return onFail(resp);
                    $scope.allowance = resp.result[0];
                    var dateRange = {
                        beginDate: moment(),
                        endDate: moment()
                    };
                    allowanceUtils.computeRemaining($scope.allowance, dateRange), extractCurrentPayType();
                }
                function onFail(resp) {
                    modals.open("500", {
                        details: resp
                    });
                }
                $scope.allowance = null, $scope.payType = null;
                var params = {
                    empId: $scope.empId,
                    year: moment().year()
                };
                return $scope.request.allowance = !0, allowanceApi.get(params, onSuccess, onFail).$promise.finally(function() {
                    $scope.request.allowance = !1;
                });
            }
            function onEmpSupInfoChange() {
                setEmpId(), getAllowance();
            }
            function extractCurrentPayType() {
                $scope.allowance && $scope.allowance.salaryRecs && $scope.allowance.salaryRecs.forEach(function(salaryRec) {
                    var startDate = moment(salaryRec.effectDate), endDate = moment(salaryRec.endDate || "3000-01-01");
                    moment().isBefore(startDate) || moment().isAfter(endDate, "day") || ($scope.payType = salaryRec.payType);
                });
            }
            function setEmpId() {
                $scope.empSupInfo && $scope.empSupInfo.empId ? $scope.empId = $scope.empSupInfo.empId : $scope.empId = appProps.user.employeeId;
            }
            $scope.allowance = null, $scope.payType = null, $scope.request = {
                allowance: !1
            }, $scope.hideTitle = "true" === $attrs.hideTitle, $scope.$watch("empSupInfo", onEmpSupInfoChange), 
            $scope.isUser = function() {
                return $scope.empId === appProps.user.employeeId;
            };
        }
    };
}

function allowanceUtils($filter) {
    function computeRemaining(allowance, dateRange) {
        var highestRate = 0;
        angular.forEach(allowance.salaryRecs, function(salaryRec) {
            "TE" !== salaryRec.payType || moment(salaryRec.effectDate).isAfter(dateRange.endDate) || moment(dateRange.beginDate).isAfter(salaryRec.endDate) || salaryRec.salaryRate > highestRate && (highestRate = salaryRec.salaryRate);
        }), allowance.remainingAllowance = allowance.yearlyAllowance - allowance.moneyUsed, 
        allowance.remainingHours = allowance.remainingAllowance / highestRate, allowance.remainingHours = $filter("round")(allowance.remainingHours, .25, -1), 
        allowance.totalHours = allowance.hoursUsed + allowance.remainingHours;
    }
    function getAvailableHours(allowance, tempWorkHours) {
        var remainingHours = (allowance || {}).remainingHours;
        return remainingHours - tempWorkHours;
    }
    return {
        computeRemaining: computeRemaining,
        getAvailableHours: getAvailableHours
    };
}

function employeeSearchCtrl($scope, modals, allowanceUtils, accrualPeriodApi, allowanceApi) {
    function getAccruals() {
        function onSuccess(resp) {
            $scope.accruals = resp.result;
        }
        function onFail(resp) {
            modals.open("500", {
                details: resp
            });
        }
        if ($scope.accruals = null, $scope.selectedEmp && !($scope.selectedEmp.senator || [ "RA", "SA" ].indexOf($scope.selectedEmp.payType) < 0)) {
            var params = {
                empId: $scope.selectedEmp.empId,
                beforeDate: moment().format("YYYY-MM-DD")
            };
            $scope.loadingAccruals = !0, accrualPeriodApi.get(params, onSuccess, onFail).$promise.finally(function() {
                $scope.loadingAccruals = !1;
            });
        }
    }
    function getAllowance() {
        function onSuccess(resp) {
            $scope.allowance = resp.result[0], allowanceUtils.computeRemaining($scope.allowance, {
                beginDate: moment(),
                endDate: moment("3000-01-01")
            });
        }
        function onFail(resp) {
            modals.open("500", {
                details: resp
            });
        }
        if ($scope.allowance = null, $scope.selectedEmp && !$scope.selectedEmp.senator && "TE" === $scope.selectedEmp.payType) {
            var params = {
                empId: $scope.selectedEmp.empId,
                year: moment().year()
            };
            $scope.loadingAllowance = !0, allowanceApi.get(params, onSuccess, onFail).$promise.finally(function() {
                $scope.loadingAllowance = !1;
            });
        }
    }
    $scope.$watch("selectedEmp", getAccruals), $scope.$watch("selectedEmp", getAllowance);
}

function employeeSearchDirective($filter, appProps, modals, activeEmpApi, empInfoApi) {
    return {
        scope: {
            selectedEmp: "=?"
        },
        restrict: "E",
        templateUrl: appProps.ctxPath + "/template/time/personnel/employee-search-directive",
        link: function($scope, $elem, $attrs) {
            function getActiveEmps() {
                function onSuccess(resp) {
                    $scope.activeEmps = resp.employees, sortActiveEmps();
                }
                function onFail(resp) {
                    modals.open("500", {
                        details: resp
                    });
                }
                return $scope.loadingEmps = !0, activeEmpApi.get({}, onSuccess, onFail).$promise.finally(function() {
                    $scope.loadingEmps = !1;
                });
            }
            function getEmpInfo() {
                function onSuccess(resp) {
                    $scope.empInfo = resp.employee;
                }
                function onFail(resp) {
                    modals.open("500", {
                        details: resp
                    });
                }
                var params = {
                    empId: $scope.selectedEmp.empId,
                    detail: !0
                };
                return $scope.loadingEmpInfo = !0, empInfoApi.get(params, onSuccess, onFail).$promise.finally(function() {
                    $scope.loadingEmpInfo = !1;
                });
            }
            function sortActiveEmps() {
                $scope.activeEmps = $filter("orderBy")($scope.activeEmps, [ "lastName", "firstName" ]);
            }
            $scope.activeEmps = null, $scope.selectedEmp = null, $scope.empInfo = null, $scope.search = {
                fullName: ""
            }, getActiveEmps(), $scope.selectEmp = function(emp) {
                $scope.selectedEmp = emp, getEmpInfo();
            }, $scope.clearSelectedEmp = function() {
                $scope.selectedEmp = null, $scope.empInfo = null;
            };
        }
    };
}

function employeeSelectDirective(appProps, $filter, supEmpGroupService) {
    return {
        scope: {
            selectedSup: "=?",
            selectedEmp: "=?"
        },
        restrict: "E",
        templateUrl: appProps.ctxPath + "/template/time/personnel/employee-select",
        link: function($scope, $elem, $attrs) {
            function setSelectedEmployeeGroup() {
                $scope.iSelEmpGroup < 0 || ($scope.allEmps = supEmpGroupService.getEmpInfos($scope.iSelEmpGroup, !$scope.showSenators), 
                $scope.allEmps = $scope.allEmps.filter(employeeFilter), setEmpLabels(), $scope.selectedSup = $scope.supEmpGroups[$scope.iSelEmpGroup], 
                0 === $scope.iSelEmp ? setSelectedEmployee() : $scope.iSelEmp = 0);
            }
            function setSelectedEmployee() {
                $scope.iSelEmp < 0 || ($scope.selectedEmp = $scope.allEmps[$scope.iSelEmp]);
            }
            function setSupGroupLabels() {
                angular.forEach($scope.supEmpGroups, function(empGroup) {
                    if (empGroup.supId === appProps.user.employeeId) {
                        var supName = supEmpGroupService.getName(empGroup.supId);
                        empGroup.dropDownLabel = supName.fullName;
                    } else {
                        var supId = supEmpGroupService.getSupId(empGroup.supId), supName = supEmpGroupService.getName(supId);
                        empGroup.group = "Supervisors Under " + supName.fullName, setDropDownLabel(empGroup);
                    }
                });
            }
            function setEmpLabels() {
                angular.forEach($scope.allEmps, function(emp) {
                    if (emp.empOverride) emp.group = "Employee Overrides"; else if (emp.supOverride) {
                        var supName = supEmpGroupService.getName(emp.supId);
                        emp.group = supName && supName.lastName ? $filter("possessive")(supName.lastName) + " Employees" : "Sup Override Employees";
                    } else emp.group = "Direct Employees";
                    setDropDownLabel(emp, emp.empOverride || emp.supOverride);
                });
            }
            function setDropDownLabel(emp, override) {
                var startDate = override ? emp.effectiveStartDate : emp.supStartDate, endDate = override ? emp.effectiveEndDate : emp.supEndDate, supStartMoment = moment(startDate || "1970-01-01"), supEndMoment = moment(endDate || "2999-12-31"), name = emp.empLastName + " " + emp.empFirstName[0] + ".", dates = supStartMoment.format("MMM YYYY");
                supEndMoment.isBefore(moment(), "day") ? supStartMoment.isBefore(supEndMoment, "month") && (dates += " - " + supEndMoment.format("MMM YYYY")) : dates += " - Present", 
                emp.dropDownLabel = name + " (" + dates + ")";
            }
            function employeeFilter(empInfo) {
                return activeFilter(empInfo) && senatorFilter(empInfo) && payTypeFilter(empInfo);
            }
            function activeFilter(empInfo) {
                return !$scope.activeOnly || !moment().isAfter(empInfo.effectiveEndDate || empInfo.supEndDate, "day");
            }
            function senatorFilter(empInfo) {
                return $scope.showSenators || !empInfo.senator;
            }
            function payTypeFilter(empInfo) {
                return !$scope.payTypeFilter || $scope.payTypeRegex.test(empInfo.payType);
            }
            $scope.iSelEmpGroup = -1, $scope.iSelEmp = -1, $scope.supEmpGroups = [], $scope.allEmps = [], 
            $scope.request = {
                supervisor: !1
            }, $scope.activeOnly = "true" === ($attrs.activeOnly || "").toLowerCase(), $scope.showSenators = "true" === ($attrs.showSenators || "").toLowerCase(), 
            $attrs.payType && ($scope.payTypeFilter = !0, $scope.payTypeRegex = new RegExp($attrs.payType, "i")), 
            $scope.selectSubject = $attrs.selectSubject || "info", $scope.request.supervisor = !0, 
            supEmpGroupService.init().then(function() {
                $scope.iSelEmpGroup = 0, $scope.supEmpGroups = supEmpGroupService.getSupEmpGroupList(), 
                $scope.validSupEmpGroupCount = $scope.supEmpGroups.filter($scope.supEmpGroupFilter).length, 
                setSupGroupLabels();
            }).finally(function() {
                $scope.request.supervisor = !1;
            }), $scope.$watch("iSelEmpGroup", setSelectedEmployeeGroup), $scope.$watch("iSelEmp", setSelectedEmployee), 
            $scope.supEmpGroupFilter = function(empGroup) {
                return activeFilter(empGroup);
            };
        }
    };
}

function supEmpGroupService($filter, appProps, modals, supEmployeeApi) {
    function init() {
        return empGroupPromise || (empGroupPromise = loadSupEmpGroup()), empGroupPromise;
    }
    function getExtSupEmpGroup() {
        return extendedSupEmpGroup;
    }
    function getSupEmpGroupList() {
        return supEmpGroupList;
    }
    function getName(empId) {
        return nameMap[empId];
    }
    function getSupId(empId) {
        return supIdMap[empId];
    }
    function getTier(empId) {
        var topSupId = extendedSupEmpGroup.supId, visitedSupIds = {};
        visitedSupIds[topSupId] = !0;
        for (var currentEmpId = empId, tier = 0; currentEmpId && !visitedSupIds[currentEmpId]; ) tier++, 
        visitedSupIds[currentEmpId] = !0, currentEmpId = getSupId(currentEmpId);
        return tier;
    }
    function getEmpInfos(iSupEmpGroup, omitSenators) {
        if (iSupEmpGroup < 0 || iSupEmpGroup > supEmpGroupList.length) throw "sup emp group index out of bounds: " + iSupEmpGroup;
        var selEmpGroup = supEmpGroupList[iSupEmpGroup], isUser = selEmpGroup.supId === extendedSupEmpGroup.supId, empList = [], primaryEmps = sortEmpInfos(selEmpGroup.primaryEmployees);
        return angular.forEach(primaryEmps, function(emp) {
            empList.push(emp);
        }), isUser && (angular.forEach(selEmpGroup.empOverrideEmployees, function(emp) {
            emp.empOverride = !0, empList.push(emp);
        }), angular.forEach(selEmpGroup.supOverrideEmployees.items, function(supGroup, supId) {
            angular.forEach(supGroup, function(emp) {
                emp.supOverride = !0, empList.push(emp);
            });
        })), empList.filter(function(emp) {
            return !(omitSenators && emp.senator);
        });
    }
    function loadSupEmpGroup() {
        function onSuccess(response) {
            extendedSupEmpGroup = response.result, setEmpMaps(), setSupEmpGroups();
        }
        function onFail(response) {
            modals.open("500", {
                details: response
            });
        }
        var fromDateMoment = moment().subtract(2, "years"), params = {
            supId: appProps.user.employeeId,
            fromDate: fromDateMoment.format("YYYY-MM-DD"),
            extended: !0
        };
        return supEmployeeApi.get(params, onSuccess, onFail).$promise;
    }
    function setEmpMaps() {
        var primaryEmpInfos = extendedSupEmpGroup.primaryEmployees, empOverrideInfos = extendedSupEmpGroup.empOverrideEmployees, supOverrideInfos = Object.keys(extendedSupEmpGroup.supOverrideEmployees).map(function(k) {
            return extendedSupEmpGroup.supOverrideEmployees[k];
        }), allEmpInfos = primaryEmpInfos.concat(empOverrideInfos).concat(supOverrideInfos), empSupEmpGroupMap = extendedSupEmpGroup.employeeSupEmpGroups;
        angular.forEach(empSupEmpGroupMap, function(supEmpGroups) {
            angular.forEach(supEmpGroups, function(supEmpGroup) {
                allEmpInfos = allEmpInfos.concat(supEmpGroup.primaryEmployees);
            });
        }), angular.forEach(allEmpInfos, function(empInfo) {
            nameMap[empInfo.empId] = {
                firstName: empInfo.empFirstName,
                lastName: empInfo.empLastName,
                fullName: empInfo.empFirstName + " " + empInfo.empLastName
            }, supIdMap[empInfo.empId] = empInfo.supId;
        }), nameMap[appProps.user.employeeId] = {
            firstName: appProps.user.firstName,
            lastName: appProps.user.lastName,
            fullName: appProps.user.firstName + " " + appProps.user.lastName
        };
    }
    function setSupEmpGroups() {
        var empSupEmpGroups = [];
        angular.forEach(extendedSupEmpGroup.employeeSupEmpGroups, function(supEmpGroups) {
            angular.forEach(supEmpGroups, function(empGroup) {
                empGroup.supStartDate = empGroup.effectiveFrom, empGroup.supEndDate = empGroup.effectiveTo, 
                empGroup.empFirstName = nameMap[empGroup.supId].firstName, empGroup.empLastName = nameMap[empGroup.supId].lastName, 
                empSupEmpGroups.push(empGroup);
            });
        }), empSupEmpGroups = $filter("orderBy")(empSupEmpGroups, [ getSupEmpGroupTier, "empLastName", "empfirstName", "supId", "effectiveEndDate" ]), 
        supEmpGroupList = [ extendedSupEmpGroup ].concat(empSupEmpGroups);
    }
    function getSupEmpGroupTier(supEmpGroup) {
        return getTier(supEmpGroup.supId);
    }
    function sortEmpInfos(empInfoList) {
        return $filter("orderBy")(empInfoList, [ "empLastName", "empFirstName", "empId", "effectiveEndDate" ]);
    }
    var extendedSupEmpGroup = null, supEmpGroupList = [], nameMap = {}, supIdMap = {}, empGroupPromise = null;
    return init(), {
        init: init,
        getExtSupEmpGroup: getExtSupEmpGroup,
        getSupEmpGroupList: getSupEmpGroupList,
        getName: getName,
        getSupId: getSupId,
        getTier: getTier,
        getEmpInfos: getEmpInfos
    };
}

function entryHoursFilter() {
    var unenteredValue = "--";
    return function(value) {
        return isNaN(parseInt(value)) ? unenteredValue : value;
    };
}

function timeRecordInputDirective() {
    var restrictedKeys = [ "e", "E", "-", "+" ];
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            element.on("focus", function(event) {
                $(this).parent().parent().addClass("active");
            }), element.on("blur", function(event) {
                $(this).parent().parent().removeClass("active");
            }), element.on("keypress", function(event) {
                restrictedKeys.indexOf(event.key) >= 0 && event.preventDefault();
            });
        }
    };
}

function recordDetailsDirective(appProps, modals, accrualApi, allowanceApi, allowanceUtils) {
    return {
        scope: {
            record: "="
        },
        templateUrl: appProps.ctxPath + "/template/time/record/details",
        link: function($scope, $elem, $attrs) {
            function detectPayTypes() {
                $scope.tempEntries = $scope.annualEntries = !1, angular.forEach($scope.record.timeEntries, function(entry) {
                    $scope.tempEntries = $scope.tempEntries || "TE" === entry.payType, $scope.annualEntries = $scope.annualEntries || [ "RA", "SA" ].indexOf(entry.payType) > -1;
                }), $scope.showAccruals = showAccrualsSelected && $scope.annualEntries, $scope.showAllowance = showAccrualsSelected && $scope.tempEntries;
            }
            function loadAccruals() {
                if ($scope.showAccruals) {
                    var record = $scope.record, empId = record.employeeId, recordStartDate = moment(record.beginDate), params = {
                        empId: empId,
                        beforeDate: recordStartDate.format("YYYY-MM-DD")
                    };
                    return $scope.loadingAccruals = !0, accrualApi.get(params, function(resp) {
                        resp.success && ($scope.accrual = resp.result);
                    }, function(resp) {
                        modals.open("500", {
                            details: resp
                        });
                    }).$promise.finally(function() {
                        $scope.loadingAccruals = !1;
                    });
                }
            }
            function loadAllowance() {
                function onSuccess(resp) {
                    var results = resp.result || [];
                    return 1 !== results.length ? onFail(resp) : ($scope.allowance = resp.result[0], 
                    void allowanceUtils.computeRemaining($scope.allowance, record));
                }
                function onFail(resp) {
                    modals.open("500", {
                        details: resp
                    });
                }
                if ($scope.showAllowance) {
                    var record = $scope.record, empId = record.employeeId, year = moment(record.endDate).year(), params = {
                        empId: empId,
                        year: year
                    };
                    return $scope.loadingAllowance = !0, allowanceApi.get(params, onSuccess, onFail).$promise.finally(function() {
                        $scope.loadingAllowance = !1;
                    });
                }
            }
            var showAccrualsSelected = "true" === $attrs.showAccruals;
            $scope.close = modals.reject, $scope.showExitBtn = "false" !== $attrs.exitBtn, $scope.showAccruals = showAccrualsSelected, 
            $scope.loadingAccruals = !1, $scope.loadingAllowance = !1, $scope.$watch("record", function(record) {
                record && (detectPayTypes(), loadAccruals(), loadAllowance());
            });
        }
    };
}

function recordDetailModalDirective(modals) {
    return {
        template: '<div class="record-detail-modal" record-details record="record"></div>',
        link: function($scope, $elem, $attrs) {
            var params = modals.params();
            $scope.record = params.record;
        }
    };
}

function recordEntryCtrl($scope, $rootScope, $filter, $q, $timeout, appProps, activeRecordsApi, recordSaveApi, accrualPeriodApi, allowanceApi, miscLeaveGrantApi, holidayApi, recordCreationApi, activeRow, recordUtils, locationService, modals, promiseUtils, allowanceUtils) {
    function getInitialState() {
        return {
            empId: appProps.user.employeeId,
            miscLeaves: appProps.miscLeaves,
            miscLeaveGrants: null,
            accrual: null,
            allowances: {},
            selectedYear: 0,
            records: [],
            iSelectedRecord: 0,
            salaryRecs: [],
            iSelSalRec: 0,
            tempEntries: !1,
            annualEntries: !1,
            totals: {},
            holidays: null,
            request: {
                records: !1,
                accruals: !1,
                allowances: !1,
                save: !1
            }
        };
    }
    function saveRecord(submit) {
        var record = $scope.state.records[$scope.state.iSelectedRecord];
        return $scope.state.request.save = !0, modals.open(submit ? "submit-progress" : "save-progress"), 
        recordSaveApi.save({
            action: submit ? "submit" : "save"
        }, record, function(resp) {
            modals.resolve();
        }, function(resp) {
            modals.reject();
            var errorMap = (((resp || {}).data || {}).errorData || {}).items || {}, errorCodes = Object.keys(errorMap).map(parseInt), modified = errorCodes.filter(function(errorCode) {
                return modifiedErrorCodes.indexOf(errorCode) >= 0;
            }).length > 0;
            modified ? modals.open("record-modified-dialog").then($scope.init).catch(function() {
                modals.open("500", {
                    details: resp
                });
            }) : modals.open("500", {
                details: resp
            });
        }).$promise.finally(function() {
            $scope.state.request.save = !1;
        });
    }
    function getAccrualTabIndexFn(propName) {
        return function(entry) {
            return null !== entry[propName] && $scope.getSelectedRecord().focused ? 1 : entry.total < 7 && !$scope.isWeekend(entry.date) ? 1 : $scope.isFieldSelected(entry, propName) ? 1 : -1;
        };
    }
    function onRecordChange() {
        var record = $scope.state.records[$scope.state.iSelectedRecord];
        recordUtils.calculateDailyTotals(record), $scope.state.totals = recordUtils.getRecordTotals(record);
    }
    function detectPayTypes() {
        if ($scope.state.tempEntries = $scope.state.annualEntries = !1, $scope.state.records.length > 0) {
            var record = $scope.getSelectedRecord();
            for (var iEntry in record.timeEntries) {
                var entry = record.timeEntries[iEntry];
                isTemporaryEmployee(entry) ? $scope.state.tempEntries = !0 : isSalariedEmployee(entry) && ($scope.state.annualEntries = !0);
            }
        }
    }
    function getSelectedSalaryRecs() {
        var salaryRecs = [];
        if ($scope.state.salaryRecs = salaryRecs, $scope.state.iSelSalRec = 0, $scope.state.tempEntries) {
            var allowance = $scope.state.allowances[$scope.state.selectedYear], record = $scope.getSelectedRecord(), highestRate = 0;
            angular.forEach(allowance.salaryRecs, function(salaryRec) {
                "TE" !== salaryRec.payType || moment(salaryRec.effectDate).isAfter(record.endDate) || moment(record.beginDate).isAfter(salaryRec.endDate) || (salaryRecs.push(salaryRec), 
                salaryRec.salaryRate > highestRate && (highestRate = salaryRec.salaryRate, $scope.state.iSelSalRec = allowance.salaryRecs.indexOf(salaryRec)));
            }), allowanceUtils.computeRemaining(allowance, record);
        }
    }
    function getLatestRecord() {
        var latestRecord = null;
        return angular.forEach($scope.state.allRecords, function(record) {
            latestRecord && !moment(record.beginDate).isAfter(latestRecord.beginDate) || (latestRecord = record);
        }), latestRecord;
    }
    function allFalse(object) {
        if ("boolean" == typeof object) return object;
        for (var prop in object) if (object.hasOwnProperty(prop) && allFalse(object[prop])) return !1;
        return !0;
    }
    function setRecordSearchParams() {
        var record = $scope.state.records[$scope.state.iSelectedRecord];
        locationService.setSearchParam("record", record.beginDate);
    }
    function linkRecordFromQueryParam() {
        var recordParam = locationService.getSearchParam("record");
        if (recordParam) for (var iRecord in $scope.state.records) {
            var record = $scope.state.records[iRecord];
            if (record.beginDate === recordParam) {
                $scope.state.iSelectedRecord = parseInt(iRecord);
                break;
            }
        }
    }
    function isTemporaryEmployee(entry) {
        return "TE" === entry.payType;
    }
    function isSalariedEmployee(entry) {
        return "RA" === entry.payType || "SA" === entry.payType;
    }
    function getSubmitDialogs() {
        var submitDialogs = [];
        return $scope.expectedHoursEntered() || submitDialogs.push(function() {
            return modals.open("expectedhrs-dialog", {
                serviceYtd: $scope.state.accrual.serviceYtd,
                serviceYtdExpected: $scope.state.accrual.serviceYtdExpected,
                biWeekHrsExpected: $scope.state.accrual.biWeekHrsExpected,
                raSaTotal: $scope.state.totals.raSaTotal
            }, !0);
        }), $scope.futureEndDate() && submitDialogs.push(function() {
            return modals.open("futureenddt-dialog", {}, !0);
        }), submitDialogs;
    }
    function fullValidationCheck() {
        $scope.preValidation();
        var record = $scope.getSelectedRecord(), recordValid = !0;
        return record && record.timeEntries && angular.forEach(record.timeEntries, function(entry) {
            recordValid &= checkEntry(entry);
        }), recordValid;
    }
    function checkEntry(entry) {
        var validationType = isSalariedEmployee(entry) ? "raSa" : "te", entryValid = !0;
        return angular.forEach($scope.entryValidators[validationType], function(validate) {
            entryValid &= validate(entry);
        }), entryValid;
    }
    function checkForPrevUnsubmitted(record) {
        for (var iRecord in $scope.state.records) {
            var otherRecord = $scope.state.records[iRecord];
            if (moment(otherRecord.beginDate).isBefore(record.beginDate)) for (var iEntry in otherRecord.timeEntries) if (isSalariedEmployee(otherRecord.timeEntries[iEntry])) return void ($scope.errorTypes.record.prevUnsubmittedRecord = !0);
        }
    }
    function isEnoughSickTime() {
        var sickTotal = $scope.state.totals.sickEmpHours + $scope.state.totals.sickFamHours;
        return !($scope.state.accrual && sickTotal > $scope.state.accrual.sickAvailable) || ($scope.errorTypes.raSa.notEnoughSickTime = !0, 
        !1);
    }
    function checkRaSaHourIncrements(hours) {
        return !(!isNaN(hours) && hours % 1 % .5 !== 0) || ($scope.errorTypes.raSa.halfHourIncrements = !0, 
        !1);
    }
    function checkTeHourIncrements(hours) {
        return !(!isNaN(hours) && hours % 1 % .25 !== 0) || ($scope.errorTypes.te.fifteenMinIncrements = !0, 
        !1);
    }
    var modifiedErrorCodes = [ 2, 7 ];
    $scope.state = null, $scope.initializeState = function() {
        $scope.state = getInitialState();
    }, $scope.init = function() {
        $scope.initializeState(), $scope.getRecords(), $scope.getMiscLeaveTypeGrants(), 
        $scope.getHolidays();
    }, $scope.$watchGroup([ "state.records", "state.iSelectedRecord" ], function() {
        $scope.state.records && $scope.state.records[$scope.state.iSelectedRecord] && (detectPayTypes(), 
        $q.all([ $scope.getAccrualForSelectedRecord(), $scope.getAllowanceForSelRecord() ]).then(function() {
            getSelectedSalaryRecs(), onRecordChange(), setRecordSearchParams(), fullValidationCheck();
        }));
    }), $scope.getRecords = function() {
        $scope.initializeState(), $scope.state.request.records = !0;
        var params = {
            empId: $scope.state.empId
        };
        activeRecordsApi.get(params, function(response) {
            $scope.state.empId in response.result.items && ($scope.state.allRecords = response.result.items[$scope.state.empId], 
            $scope.state.records = $scope.state.allRecords.filter(function(record) {
                return "E" === record.scope;
            }), angular.forEach($scope.state.records, function(record, index) {
                var endDateMoment = moment(record.endDate).add(1, "days").startOf("day");
                record.dueFromNowStr = endDateMoment.fromNow(!1), record.isDue = endDateMoment.isBefore(moment()), 
                record.index = index, angular.forEach(record.timeEntries, function(entry, i) {
                    entry.index = i;
                }), record.initialRemarks = record.remarks;
            }), linkRecordFromQueryParam());
        }, function(response) {
            modals.open("500", {
                action: "get active records",
                details: response
            });
        }).$promise.finally(function() {
            $scope.state.request.records = !1;
        });
    }, $scope.saveRecord = function(submit) {
        var record = $scope.state.records[$scope.state.iSelectedRecord];
        fullValidationCheck();
        var entryErrors = $scope.selRecordHasEntryErrors();
        if (entryErrors || submit && $scope.selRecordHasRecordErrors()) return void $scope.$broadcast("validateRecordEntries");
        var confirmPromise = $q.when();
        submit && (confirmPromise = promiseUtils.serial(getSubmitDialogs()).then(function() {
            return modals.open("submit-ack", {
                record: record
            }, !0);
        }));
        var saveSuccess = !1;
        confirmPromise.then(function() {
            return saveRecord(submit);
        }).then(function() {
            return saveSuccess = !0, $q.when();
        }).then(function() {
            return modals.open(submit ? "post-submit" : "post-save");
        }).then($scope.init, function() {
            saveSuccess && $scope.logout();
        });
    }, $scope.getAccrualForSelectedRecord = function() {
        if ($scope.state.annualEntries) {
            var empId = $scope.state.empId, record = $scope.state.records[$scope.state.iSelectedRecord], periodStartMoment = moment(record.payPeriod.startDate);
            return $scope.state.request.accruals = !0, accrualPeriodApi.get({
                empId: empId,
                beforeDate: periodStartMoment.format("YYYY-MM-DD")
            }, function(resp) {
                resp.success && ($scope.state.accrual = resp.result);
            }, function(resp) {
                modals.open("500", {
                    details: resp
                });
            }).$promise.finally(function() {
                $scope.state.request.accruals = !1;
            });
        }
        return $q(function(resolve) {
            resolve();
        });
    }, $scope.getAllowanceForSelRecord = function() {
        var record = $scope.getSelectedRecord();
        if ($scope.state.selectedYear = moment(record.beginDate).year(), $scope.state.tempEntries && !$scope.state.allowances.hasOwnProperty($scope.state.selectedYear)) {
            var params = {
                empId: $scope.state.empId,
                year: $scope.state.selectedYear
            };
            return $scope.state.request.allowances = !0, allowanceApi.get(params, function(response) {
                for (var i in response.result) {
                    var allowance = response.result[i];
                    $scope.state.allowances[allowance.year] = allowance;
                }
            }, function(resp) {
                modals.open("500", {
                    details: resp
                });
            }).$promise.finally(function() {
                $scope.state.request.allowances = !1;
            });
        }
        return $q(function(resolve) {
            resolve();
        });
    }, $scope.getMiscLeaveTypeGrants = function() {
        var params = {
            empId: $scope.state.empId
        };
        miscLeaveGrantApi.get(params, function(response) {
            $scope.state.miscLeaveGrants = response.result;
        }, function(response) {
            modals.open("500", {
                details: response
            });
        });
    }, $scope.getHolidays = function() {
        var params = {
            fromDate: moment().subtract(1, "year").format("YYYY-MM-DD"),
            toDate: moment().add(1, "year").format("YYYY-MM-DD")
        };
        holidayApi.get(params, function(response) {
            $scope.state.holidays = {}, angular.forEach(response.holidays, function(holiday) {
                holiday.unofficial || ($scope.state.holidays[holiday.date] = holiday);
            });
        }, function(response) {
            modals.open("500", {
                details: response
            });
        });
    }, $scope.createNextRecord = function() {
        if ($scope.canCreateNextRecord()) {
            var latestRecord = getLatestRecord(), nextRecBeginDate = moment(latestRecord.endDate).add(1, "day");
            $scope.state.request.records = !0;
            var params = {
                empId: $scope.state.empId,
                date: nextRecBeginDate.format("YYYY-MM-DD")
            };
            recordCreationApi.save(params, {}, function(response) {
                $scope.init();
            }, function(errorResponse) {
                modals.open("500", {
                    details: errorResponse
                }), $scope.state.request.records = !1;
            });
        }
    }, $scope.getSelectedRecord = function() {
        return $scope.state.records[$scope.state.iSelectedRecord];
    }, $scope.resolveModal = function(result) {
        modals.resolve(result);
    }, $scope.rejectModal = function(reason) {
        modals.reject(reason);
    }, $scope.isWeekend = function(date) {
        return $filter("momentIsDOW")(date, [ 0, 6 ]);
    }, $scope.setDirty = function(entry) {
        $scope.state.records[$scope.state.iSelectedRecord].dirty = !0, entry && (entry.dirty = !0), 
        onRecordChange();
    }, $scope.recordValid = function() {
        var record = $scope.getSelectedRecord();
        return !(null == record || $scope.selRecordHasEntryErrors());
    }, $scope.recordSubmittable = function() {
        return !$scope.requestInProgress() && $scope.recordValid() && !$scope.selRecordHasRecordErrors();
    }, $scope.getAvailableHours = function() {
        var allowance = $scope.state.allowances[$scope.state.selectedYear], tempWorkHours = $scope.state.totals.tempWorkHours;
        return allowanceUtils.getAvailableHours(allowance, tempWorkHours);
    }, $scope.getSalRecDateRange = function(salaryRec) {
        var record = $scope.getSelectedRecord(), beginDate = moment(salaryRec.effectDate).isAfter(record.beginDate) ? salaryRec.effectDate : record.beginDate, endDate = moment(salaryRec.endDate).isAfter(record.endDate) ? record.endDate : salaryRec.endDate;
        return moment(beginDate).format("M/D") + " - " + moment(endDate).format("M/D");
    }, $scope.getSalRecStartDate = function(salaryRec) {
        var record = $scope.getSelectedRecord();
        return moment(salaryRec.effectDate).isAfter(record.beginDate) ? salaryRec.effectDate : record.beginDate;
    }, $scope.getSalRecEndDate = function(salaryRec) {
        var record = $scope.getSelectedRecord();
        return moment(salaryRec.endDate).isAfter(record.endDate) ? record.endDate : salaryRec.endDate;
    }, $scope.getRecordRangeDisplay = function(record) {
        return moment(record.beginDate).format("l") + " - " + moment(record.endDate).format("l");
    }, $rootScope.$on("validateRecordEntries", function() {
        var record = $scope.getSelectedRecord();
        record.focused = !0;
    }), $scope.isFieldSelected = function(entry, fieldName) {
        var fieldIdSelector = "#" + entry.date + "-" + fieldName;
        return angular.element(fieldIdSelector).is(":focus");
    }, $scope.accrualTabIndex = {
        holiday: getAccrualTabIndexFn("holidayHours"),
        vacation: getAccrualTabIndexFn("vacationHours"),
        personal: getAccrualTabIndexFn("personalHours"),
        sickEmp: getAccrualTabIndexFn("sickEmpHours"),
        sickFam: getAccrualTabIndexFn("sickFamHours"),
        misc: getAccrualTabIndexFn("miscHours")
    }, $scope.expectedHoursEntered = function() {
        return !$scope.state.annualEntries || $scope.state.accrual.biWeekHrsExpected <= $scope.state.totals.raSaTotal;
    }, $scope.futureEndDate = function() {
        var record = $scope.getSelectedRecord();
        return moment(record.endDate).isAfter(moment(), "day");
    }, $scope.getMiscLeavePredicate = function(date) {
        var dateMoment = moment(date);
        return function(miscLeave) {
            if (miscLeave.restricted === !1) return !0;
            for (var iGrant in $scope.state.miscLeaveGrants) {
                var grant = $scope.state.miscLeaveGrants[iGrant];
                if (!dateMoment.isBefore(grant.beginDate, "day") && !dateMoment.isAfter(grant.endDate, "day") && miscLeave.type === grant.miscLeaveType) return !0;
            }
            return !1;
        };
    }, $scope.isHoliday = function(entry) {
        return $scope.state.holidays && $scope.state.holidays.hasOwnProperty(entry.date);
    }, $scope.getHolidayHours = function(entry) {
        return $scope.state.holidays ? $scope.isHoliday(entry) ? $scope.state.holidays[entry.date].hours : 0 : 7;
    }, $scope.canCreateNextRecord = function() {
        if ($scope.state.records.length > 0) return !1;
        for (var iRecord in $scope.state.allRecords) if ($scope.state.allRecords.hasOwnProperty(iRecord)) {
            var record = $scope.state.allRecords[iRecord];
            if (moment().isBefore(record.beginDate)) return !1;
        }
        var latestRecord = getLatestRecord();
        return null !== latestRecord && !moment().isAfter(latestRecord.endDate, "day");
    }, $scope.requestInProgress = function() {
        for (var iReq in $scope.state.request) if ($scope.state.request.hasOwnProperty(iReq) && $scope.state.request[iReq] === !0) return !0;
        return !1;
    }, $scope.preValidation = function() {
        var record = $scope.getSelectedRecord();
        $scope.errorTypes.reset(), checkForPrevUnsubmitted(record);
    }, $scope.errorTypes = {
        raSa: {
            workHoursInvalidRange: !1,
            holidayHoursInvalidRange: !1,
            vacationHoursInvalidRange: !1,
            personalHoursInvalidRange: !1,
            sickEmpHoursInvalidRange: !1,
            sickFamHoursInvalidRange: !1,
            miscHoursInvalidRange: !1,
            totalHoursInvalidRange: !1,
            notEnoughVacationTime: !1,
            notEnoughPersonalTime: !1,
            notEnoughSickTime: !1,
            noMiscTypeGiven: !1,
            noMiscHoursGiven: !1,
            halfHourIncrements: !1
        },
        te: {
            workHoursInvalidRange: !1,
            notEnoughWorkHours: !1,
            noComment: !1,
            noWorkHoursForComment: !1,
            fifteenMinIncrements: !1
        },
        record: {
            prevUnsubmittedRecord: !1
        },
        reset: function(object) {
            void 0 === object && (object = this);
            var caller = this;
            angular.forEach(object, function(value, key) {
                "boolean" == typeof value ? object[key] = !1 : "object" == typeof value && caller.reset(value);
            });
        }
    }, $scope.selRecordHasEntryErrors = function() {
        return $scope.selRecordHasRaSaErrors() || $scope.selRecordHasTeErrors();
    }, $scope.selRecordHasRaSaErrors = function() {
        return !allFalse($scope.errorTypes.raSa);
    }, $scope.selRecordHasTeErrors = function() {
        return !allFalse($scope.errorTypes.te);
    }, $scope.selRecordHasRecordErrors = function() {
        return !allFalse($scope.errorTypes.record);
    }, $scope.entryValidators = {
        raSa: {
            workHours: function(entry) {
                var hrs = entry.workHours;
                if (0 === hrs || null === hrs) return !0;
                var isValid = !0;
                return "undefined" == typeof hrs && ($scope.errorTypes.raSa.workHoursInvalidRange = !0, 
                isValid = !1), isValid &= checkRaSaHourIncrements(hrs);
            },
            holidayHours: function(entry) {
                if ("SA" !== entry.payType || !$scope.state.holidays || !$scope.isHoliday(entry)) return !0;
                var hrs = entry.holidayHours, isValid = !0;
                return 0 === hrs || null === hrs || ("undefined" == typeof hrs && ($scope.errorTypes.raSa.holidayHoursInvalidRange = !0, 
                isValid = !1), isValid &= checkRaSaHourIncrements(hrs));
            },
            vacationHours: function(entry) {
                var hrs = entry.vacationHours, isValid = !0;
                return 0 === hrs || null === hrs || ($scope.state.accrual && $scope.state.totals.vacationHours > $scope.state.accrual.vacationAvailable && ($scope.errorTypes.raSa.notEnoughVacationTime = !0, 
                isValid = !1), "undefined" == typeof hrs && ($scope.errorTypes.raSa.vacationHoursInvalidRange = !0, 
                isValid = !1), isValid &= checkRaSaHourIncrements(hrs));
            },
            personalHours: function(entry) {
                var hrs = entry.personalHours, isValid = !0;
                return 0 === hrs || null === hrs || ($scope.state.accrual && $scope.state.totals.personalHours > $scope.state.accrual.personalAvailable && ($scope.errorTypes.raSa.notEnoughPersonalTime = !0, 
                isValid = !1), "undefined" == typeof hrs && ($scope.errorTypes.raSa.personalHoursInvalidRange = !0, 
                isValid = !1), isValid &= checkRaSaHourIncrements(hrs));
            },
            sickEmpHours: function(entry) {
                var hrs = entry.sickEmpHours, isValid = !0;
                return 0 === hrs || null === hrs || (isValid &= isEnoughSickTime(), "undefined" == typeof hrs && ($scope.errorTypes.raSa.sickEmpHoursInvalidRange = !0, 
                isValid = !1), isValid &= checkRaSaHourIncrements(hrs));
            },
            sickFamHours: function(entry) {
                var hrs = entry.sickFamHours, isValid = !0;
                return 0 === hrs || null === hrs || (isValid &= isEnoughSickTime(), "undefined" == typeof hrs && ($scope.errorTypes.raSa.sickFamHoursInvalidRange = !0, 
                isValid = !1), isValid &= checkRaSaHourIncrements(hrs));
            },
            miscHours: function(entry) {
                var hrs = entry.miscHours, isValid = !0;
                return 0 === hrs || null === hrs || ("undefined" == typeof hrs && ($scope.errorTypes.raSa.miscHoursInvalidRange = !0, 
                isValid = !1), isValid &= checkRaSaHourIncrements(hrs));
            },
            miscType: function(entry) {
                var miscTypePresent = null !== entry.miscType, miscHoursPresent = entry.miscHours > 0, isActiveRow = entry.index === activeRow.getActiveRow();
                return isActiveRow || miscTypePresent || !miscHoursPresent ? !(miscTypePresent && !miscHoursPresent) || ($scope.errorTypes.raSa.noMiscHoursGiven = !0, 
                !1) : ($scope.errorTypes.raSa.noMiscTypeGiven = !0, !1);
            },
            totalHours: function(entry) {
                return !!(isNaN(entry.total) || entry.total >= 0 && entry.total <= 24) || ($scope.errorTypes.raSa.totalHoursInvalidRange = !0, 
                !1);
            }
        },
        te: {
            workHours: function(entry) {
                var hrs = entry.workHours;
                if (0 === hrs || null === hrs) return !0;
                var isValid = !0;
                return "undefined" == typeof hrs && ($scope.errorTypes.te.workHoursInvalidRange = !0, 
                isValid = !1), $scope.getAvailableHours() < 0 && ($scope.errorTypes.te.notEnoughWorkHours = !0, 
                isValid = !1), isValid &= checkTeHourIncrements(hrs);
            },
            comment: function(entry) {
                var hrs = entry.workHours, comment = entry.empComment, isActiveRow = entry.index === activeRow.getActiveRow();
                return hrs > 0 && !comment && !isActiveRow ? ($scope.errorTypes.te.noComment = !0, 
                !1) : null !== hrs || !comment || ($scope.errorTypes.te.noWorkHoursForComment = !0, 
                !1);
            }
        }
    }, $scope.init();
}

function postSaveModal(appProps, modals) {
    function link($scope, $elem, $attrs) {
        var params = modals.params();
        $scope.submit = params.submit, $scope.resolve = modals.resolve, $scope.reject = modals.reject;
    }
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-post-save-modal",
        link: link
    };
}

function submitAckModal(appProps, modals) {
    function link($scope, $elem, $attrs) {
        $scope.resolve = modals.resolve, $scope.reject = modals.reject;
    }
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-submit-ack-modal",
        link: link
    };
}

function futureEndDateConfModal(appProps, modals) {
    function link($scope, $elem, $attrs) {
        $scope.resolve = modals.resolve, $scope.reject = modals.reject;
    }
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-future-end-date-conf-modal",
        link: link
    };
}

function expectedHoursModal(appProps, modals) {
    function link($scope, $elem, $attrs) {
        var params = modals.params();
        $scope.serviceYtd = params.serviceYtd, $scope.serviceYtdExpected = params.serviceYtdExpected, 
        $scope.biWeekHrsExpected = params.biWeekHrsExpected, $scope.raSaTotal = params.raSaTotal, 
        $scope.serviceSurplus = $scope.serviceYtd - $scope.serviceYtdExpected, $scope.expectedDifference = $scope.biWeekHrsExpected - $scope.raSaTotal, 
        $scope.resolve = modals.resolve, $scope.reject = modals.reject;
    }
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-expected-hrs-modal",
        link: link
    };
}

function recordHistoryCtrl($scope, $q, appProps, ActiveYearsTimeRecordsApi, timeRecordsApi, attendanceRecordApi, modals, recordUtils) {
    function initializeTimeRecords() {
        var responseRecords = $scope.state.timesheetRecords;
        for (var i in responseRecords) {
            var record = responseRecords[i];
            recordUtils.calculateDailyTotals(record), record.totals = recordUtils.getRecordTotals(record), 
            "E" === record.scope ? $scope.records.employee.push(record) : (addToAnnualTotals(record), 
            $scope.records.other.unshift(record));
        }
    }
    function initializeAttendRecords() {
        var attendRecords = $scope.state.attendRecords, recordArray = $scope.records.other;
        $scope.state.paperTimesheetsDisplayed = !1, attendRecords.map(recordUtils.formatAttendRecord).filter(useAttendRecord).forEach(function(attendRec) {
            addToAnnualTotals(attendRec), recordArray.unshift(attendRec), $scope.state.paperTimesheetsDisplayed = !0;
        });
    }
    function useAttendRecord(attendRec) {
        if (!attendRec.paperTimesheet) return !1;
        var timeRecords = $scope.state.timesheetRecords;
        for (var iTrec in timeRecords) if (timeRecords.hasOwnProperty(iTrec)) {
            var timeRec = timeRecords[iTrec];
            if (attendRec.beginDate === timeRec.beginDate && attendRec.endDate === timeRec.endDate) return !1;
        }
        return !0;
    }
    function addToAnnualTotals(record) {
        for (var field in record.totals) record.totals.hasOwnProperty(field) && ($scope.annualTotals.hasOwnProperty(field) || ($scope.annualTotals[field] = 0), 
        $scope.annualTotals[field] += record.totals[field]);
    }
    $scope.state = {
        searching: !1,
        recordYears: null,
        year: null,
        timeRecords: [],
        attendRecords: []
    }, $scope.init = function() {
        var empId = appProps.user.employeeId;
        ActiveYearsTimeRecordsApi.get({
            empId: empId
        }, function(resp) {
            $scope.state.recordYears = resp.years.reverse(), $scope.state.year = $scope.state.recordYears[0], 
            $scope.getRecords();
        }, function(resp) {
            modals.open("500", {
                action: "Get time record history",
                details: resp
            });
        });
    }, $scope.floatTheadOpts = {
        scrollingTop: 47
    }, $scope.getRecords = function() {
        $scope.state.searching = !0, $scope.records = {
            employee: [],
            other: []
        }, $scope.annualTotals = {}, $q.all([ $scope.getTimeRecords(), $scope.getAttendRecords() ]).then(function() {}).catch(function(reason) {}).finally(function() {
            $scope.state.searching = !1, initializeTimeRecords(), initializeAttendRecords(), 
            $scope.records.other.sort(recordUtils.compareRecords).reverse();
        });
    }, $scope.getTimeRecords = function() {
        var empId = appProps.user.employeeId, fromMoment = (moment(), moment([ $scope.state.year ])), toMoment = moment([ $scope.state.year + 1 ]), params = {
            empId: empId,
            from: fromMoment.format("YYYY-MM-DD"),
            to: toMoment.format("YYYY-MM-DD")
        };
        return timeRecordsApi.get(params, function(response) {
            $scope.state.timesheetRecords = response.result.items[empId];
        }, function(response) {
            modals.open("500", {
                details: response
            });
        }).$promise;
    }, $scope.getAttendRecords = function() {
        var params = {
            empId: appProps.user.employeeId,
            year: $scope.state.year
        };
        return attendanceRecordApi.get(params, function(response) {
            $scope.state.attendRecords = response.records;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        }).$promise;
    }, $scope.showDetails = function(record) {
        if (!record.paperTimesheet) {
            var params = {
                record: record
            };
            modals.open("record-details", params, !0);
        }
    }, $scope.init();
}

function recordHistoryDirective($q, appProps, modals, recordUtils, ActiveYearsTimeRecordsApi, TimeRecordsApi, AttendanceRecordApi) {
    return {
        scope: {
            empSupInfo: "=?"
        },
        templateUrl: appProps.ctxPath + "/template/time/record/history-directive",
        link: function($scope, $elem, $attrs) {
            function getTimeRecordYears() {
                var emp = $scope.state.selectedEmp;
                if (emp.empId) return $scope.state.selectedRecYear = -1, $scope.state.request.tRecYears = !0, 
                ActiveYearsTimeRecordsApi.get({
                    empId: emp.empId
                }, function(resp) {
                    var isUserSup = emp.supId === $scope.state.supId, startDate = isUserSup ? emp.supStartDate : emp.effectiveStartDate, endDate = isUserSup ? emp.supEndDate : emp.effectiveEndDate, supStartYear = moment(startDate || 0).year(), supEndYear = moment(endDate || void 0).year();
                    $scope.state.recordYears = resp.years.filter(function(year) {
                        return year >= supStartYear && year <= supEndYear;
                    }).reverse(), $scope.state.selectedRecYear = $scope.state.recordYears.length > 0 && $scope.state.recordYears[0];
                }, function(resp) {
                    modals.open("500", {
                        details: resp
                    });
                }).$promise.finally(function() {
                    $scope.state.request.tRecYears = !1;
                });
            }
            function getRecords() {
                var emp = $scope.state.selectedEmp;
                if (emp.empId) {
                    var year = $scope.state.selectedRecYear;
                    if (year && !(year < 0)) {
                        $scope.state.records = [], $scope.state.attendRecords = [], $scope.state.timesheetRecords = [];
                        var isUserSup = emp.supId === $scope.state.supId, supStartDate = isUserSup ? emp.supStartDate : emp.effectiveStartDate, supEndDate = isUserSup ? emp.supEndDate : emp.effectiveEndDate, yearStart = moment([ year ]), nextYearStart = moment([ year + 1 ]), supStartMoment = moment(supStartDate || 0), supEndMoment = moment(supEndDate || [ 3e3 ]), fromMoment = moment.max(yearStart, supStartMoment), toMoment = moment.min(nextYearStart, supEndMoment);
                        if (fromMoment.isAfter(toMoment)) return void ($scope.state.records = []);
                        $scope.state.request.records = !0, $q.all([ getTimesheetRecords(emp.empId, fromMoment, toMoment), getAttendRecords(emp.empId, fromMoment, toMoment) ]).then(function() {
                            initTimesheetRecords(), initAttendRecords(), combineRecords();
                        }).finally(function() {
                            $scope.state.request.records = !1;
                        });
                    }
                }
            }
            function getTimesheetRecords(empId, from, to) {
                var params = {
                    empId: empId,
                    from: moment(from).format("YYYY-MM-DD"),
                    to: moment(to).format("YYYY-MM-DD")
                };
                return TimeRecordsApi.get(params, function(resp) {
                    $scope.state.timesheetRecords = (resp.result.items[empId] || []).reverse();
                }, $scope.handleErrorResponse).$promise;
            }
            function getAttendRecords(empId, from, to) {
                var params = {
                    empId: empId,
                    from: moment(from).format("YYYY-MM-DD"),
                    to: moment(to).format("YYYY-MM-DD")
                };
                return AttendanceRecordApi.get(params, function(response) {
                    $scope.state.attendRecords = response.records;
                }, $scope.handleErrorResponse).$promise;
            }
            function setEmpId() {
                $scope.empSupInfo && $scope.empSupInfo.empId ? $scope.state.selectedEmp = $scope.empSupInfo : $scope.state.selectedEmp = {
                    empId: appProps.user.employeeId
                };
            }
            function initTimesheetRecords() {
                $scope.state.timesheetMap = {}, angular.forEach($scope.state.timesheetRecords, function(record) {
                    recordUtils.calculateDailyTotals(record), record.totals = recordUtils.getRecordTotals(record), 
                    $scope.state.timesheetMap[record.timeRecordId] = record;
                });
            }
            function initAttendRecords() {
                $scope.state.attendRecords.forEach(recordUtils.formatAttendRecord);
            }
            function combineRecords() {
                $scope.state.records = [], $scope.state.paperTimesheetsDisplayed = !1;
                var attendEnd = moment("1970-01-01T00:00:00");
                angular.forEach($scope.state.attendRecords, function(attendRecord) {
                    return moment(attendRecord.endDate).isAfter(attendEnd) && (attendEnd = attendRecord.endDate), 
                    0 === attendRecord.timesheetIds.length ? ($scope.state.paperTimesheetsDisplayed = !0, 
                    void $scope.state.records.push(attendRecord)) : void angular.forEach(attendRecord.timesheetIds, function(tsId) {
                        var record = $scope.state.timesheetMap[tsId];
                        record && $scope.state.records.push(record);
                    });
                }), angular.forEach($scope.state.timesheetRecords, function(timesheet) {
                    moment(timesheet.endDate).isAfter(attendEnd) && $scope.state.records.push(timesheet);
                }), $scope.state.records.sort(recordUtils.compareRecords).reverse();
            }
            $scope.state = {
                supId: appProps.user.employeeId,
                searching: !1,
                request: {
                    tRecYears: !1,
                    records: !1
                },
                todayMoment: moment(),
                selectedEmp: {},
                empId: null,
                recordYears: [],
                selectedRecYear: -1,
                records: [],
                timesheetMap: {},
                timesheetRecords: [],
                attendRecords: []
            }, $scope.hideTitle = "true" === $attrs.hideTitle, $scope.$watchCollection("empSupInfo", setEmpId), 
            $scope.$watchCollection("empSupInfo", getTimeRecordYears), $scope.$watch("state.selectedRecYear", getRecords), 
            $scope.showDetails = function(record) {
                if (!record.paperTimesheet) {
                    var params = {
                        record: record
                    };
                    modals.open("record-details", params, !0);
                }
            }, $scope.isLoading = function() {
                for (var request in $scope.state.request) if ($scope.state.request.hasOwnProperty(request) && $scope.state.request[request] === !0) return !0;
                return !1;
            }, $scope.isUser = function() {
                return $scope.state.selectedEmp.empId === appProps.user.employeeId;
            };
        }
    };
}

function recordManageCtrl($scope, $q, $filter, appProps, recordUtils, modals, badgeService, supEmpGroupService, supRecordsApi, timeRecordReviewApi, reminderApi) {
    function getActiveRecordsForSelSup() {
        var supEntry = $scope.getSelSupEntry();
        supEntry && getEmployeeActiveRecords(supEntry);
    }
    function getEmployeeActiveRecords(supEntry) {
        function onSuccess(resp) {
            initializeRecords(querySupId, resp.result.items), resetSelection();
        }
        function onFail(resp) {
            modals.open("500", {
                details: resp
            });
        }
        var querySupId = supEntry.querySupId, fromMoment = moment().subtract(1, "year"), toMoment = moment().add(1, "month");
        supEntry.extendedSup && (fromMoment = moment.max(fromMoment, moment(supEntry.effectiveFrom)), 
        toMoment = moment.min(toMoment, moment(supEntry.effectiveTo)));
        var params = {
            from: fromMoment.format("YYYY-MM-DD"),
            to: toMoment.format("YYYY-MM-DD"),
            supId: querySupId
        };
        return $scope.state.request.records = !0, supRecordsApi.get(params, onSuccess, onFail).$promise.finally(function() {
            $scope.state.request.records = !1;
        });
    }
    function submitRecords(records) {
        var promises = [];
        return records.forEach(function(record) {
            var params = {
                timeRecordId: record.timeRecordId,
                action: record.action,
                remarks: record.remarks
            };
            promises.push(timeRecordReviewApi.save(params, {}, function(response) {}, function(response) {
                return response;
            }).$promise);
        }), $scope.state.request.recordSubmit = !0, $q.all(promises).then(function() {
            getEmployeeActiveRecords($scope.state.supervisors[0]).then(function() {
                $scope.getSelSupEntry().querySupId !== appProps.user.employeeId && getEmployeeActiveRecords($scope.getSelSupEntry());
            });
        }, function(resp) {
            modals.open("500", {
                details: resp
            });
        }).finally(function() {
            $scope.state.request.recordSubmit = !1;
        });
    }
    function postReminders(timeRecords) {
        if (!timeRecords) return $q.when();
        var empIds = [], beginDates = [];
        timeRecords.forEach(function(record) {
            empIds.push(record.employeeId), beginDates.push(record.beginDate);
        });
        var params = {
            empId: empIds,
            beginDate: beginDates
        };
        return modals.open("record-reminder-posting"), reminderApi.save(params, {}, function() {}, function(errorData) {
            modals.rejectAll(), modals.open("500", {
                details: errorData
            });
        }).$promise;
    }
    function initializeSupervisors() {
        $scope.state.supervisors = getPrimarySupEntries().concat(getOverrideSupEntries()).concat(getEmpOverrideEntries()).concat(getExtendedSupEntries()), 
        $scope.state.iSelSup = 0;
    }
    function getPrimarySupEntries() {
        var primarySupEntries = [], supId = appProps.user.employeeId, extSupEmpGroup = supEmpGroupService.getExtSupEmpGroup(), supName = supEmpGroupService.getName(supId), hasSupOverrides = extSupEmpGroup.supOverrideEmployees.size > 0, hasEmpOverrides = extSupEmpGroup.empOverrideEmployees.length > 0, fullEmpGroupEntry = {
            querySupId: supId,
            supId: supId,
            name: supName,
            baseLabel: supName.fullName,
            dropDownLabel: supName.fullName,
            fullEmpGroup: !0,
            userResponsible: !0
        };
        if (primarySupEntries.push(fullEmpGroupEntry), hasSupOverrides || hasEmpOverrides) {
            var supEmpGroupEntry = angular.copy(fullEmpGroupEntry);
            supEmpGroupEntry.fullEmpGroup = !1, primarySupEntries.push(supEmpGroupEntry);
            var fullEmpGroupBaseLabel = supName.fullName + " + Overrides";
            fullEmpGroupEntry.baseLabel = fullEmpGroupBaseLabel, fullEmpGroupEntry.dropDownLabel = fullEmpGroupBaseLabel;
        }
        return primarySupEntries;
    }
    function getOverrideSupEntries() {
        var extSupEmpGroup = supEmpGroupService.getExtSupEmpGroup(), supOverrides = {}, supOverrideGroup = "Supervisor Overrides";
        angular.forEach(extSupEmpGroup.supOverrideEmployees.items, function(empInfos, supId) {
            supId = parseInt(supId);
            var name = supEmpGroupService.getName(supId), baseLabel = getSupNameLabel(name);
            supOverrides[supId] = {
                querySupId: appProps.user.employeeId,
                supId: supId,
                name: name,
                group: supOverrideGroup,
                baseLabel: baseLabel,
                dropDownLabel: baseLabel,
                supOverride: !0,
                userResponsible: !0
            };
        });
        var supOvrList = Object.keys(supOverrides).map(function(k) {
            return supOverrides[k];
        });
        return supOvrList = $filter("orderBy")(supOvrList, "dropDownLabel");
    }
    function getEmpOverrideEntries() {
        var extSupEmpGroup = supEmpGroupService.getExtSupEmpGroup(), empOverrides = {}, empOverrideGroup = "Employee Overrides";
        angular.forEach(extSupEmpGroup.empOverrideEmployees, function(empInfo) {
            var name = supEmpGroupService.getName(empInfo.empId), baseLabel = getSupNameLabel(name);
            empOverrides[empInfo.empId] = {
                querySupId: appProps.user.employeeId,
                supId: empInfo.supId,
                ovrEmpId: empInfo.empId,
                name: name,
                group: empOverrideGroup,
                baseLabel: baseLabel,
                dropDownLabel: baseLabel,
                empOverride: !0,
                userResponsible: !0
            };
        });
        var empOvrList = Object.keys(empOverrides).map(function(k) {
            return empOverrides[k];
        });
        return empOvrList = $filter("orderBy")(empOvrList, "dropDownLabel");
    }
    function getExtendedSupEntries() {
        var supEmpGroups = supEmpGroupService.getSupEmpGroupList(), extSupEntries = supEmpGroups.slice(1).filter(function(empGroup) {
            return moment().subtract(1, "year").isBefore(empGroup.effectiveTo);
        }).map(function(empGroup) {
            var supId = empGroup.supId, name = supEmpGroupService.getName(supId), baseLabel = getSupNameLabel(name), supSupId = supEmpGroupService.getSupId(empGroup.supId), supSupName = supEmpGroupService.getName(supSupId), extSupGroup = "Supervisors Under " + supSupName.fullName;
            return {
                querySupId: supId,
                supId: supId,
                name: name,
                group: extSupGroup,
                baseLabel: baseLabel,
                dropDownLabel: baseLabel,
                extendedSup: !0,
                effectiveFrom: empGroup.effectiveFrom,
                effectiveTo: empGroup.effectiveTo
            };
        });
        return extSupEntries;
    }
    function getSupNameLabel(name) {
        return name.lastName + ", " + name.firstName;
    }
    function initializeRecords(supId, recordMap) {
        var isUser = supId === appProps.user.employeeId, affectedSupervisors = $scope.state.supervisors.filter(function(supEntry) {
            return supEntry.querySupId === supId;
        });
        affectedSupervisors.forEach(function(supEntry) {
            supEntry.records = {};
        }), angular.forEach(recordMap, function(records, empId) {
            angular.forEach(records, function(record) {
                (isUser || record.supervisorId === supId) && ("E" === record.scope && recordUtils.isFullTempRecord(record) && !recordUtils.recordHasEnteredTime(record) || (recordUtils.calculateDailyTotals(record), 
                record.totals = recordUtils.getRecordTotals(record), affectedSupervisors.filter(function(supEntry) {
                    return supEntry.fullEmpGroup || supEntry.supId === record.supervisorId && (!supEntry.ovrEmpId || supEntry.ovrEmpId === record.employeeId);
                }).forEach(function(supEntry) {
                    var status = record.recordStatus, statusList = supEntry.records[status] = supEntry.records[status] || [];
                    statusList.push(record);
                })));
            });
        }), affectedSupervisors.forEach(function(supEntry) {
            angular.forEach(supEntry.records, function(recordList, index) {
                supEntry.records[index] = $filter("orderBy")(recordList, [ "employee.lastName", "employee.firstName", "beginDate" ]);
            });
        }), isUser && updatePendingRecordCounts();
    }
    function updatePendingRecordCounts() {
        angular.forEach($scope.state.supervisors, function(supEntry) {
            if (!supEntry.extendedSup) {
                var count = getRecords(supEntry, "SUBMITTED").length;
                supEntry.fullEmpGroup && badgeService.setBadgeValue("pendingRecordCount", count);
                var pendingText = " - (" + count + " Pending Records)";
                supEntry.dropDownLabel = supEntry.baseLabel + pendingText;
            }
        });
    }
    function getRecords(supEntry, status) {
        var statusMap = supEntry.records || {};
        return statusMap[status] || [];
    }
    function getSelectedRecords(status) {
        var selectedRecords = [], selectedSup = $scope.getSelSupEntry(), statusRecords = getRecords(selectedSup, status), selectedIndices = $scope.state.selectedIndices[status];
        for (var index in selectedIndices) selectedIndices.hasOwnProperty(index) && selectedIndices[index] && statusRecords.hasOwnProperty(index) && selectedRecords.push(statusRecords[index]);
        return selectedRecords;
    }
    function submitReviewedRecords(reviewedRecords) {
        var recordsToSubmit = [];
        angular.forEach(reviewedRecords.approved, function(record) {
            record.action = "submit", recordsToSubmit.push(record);
        }), angular.forEach(reviewedRecords.disapproved, function(record) {
            record.action = "reject", record.remarks = record.rejectionRemarks, recordsToSubmit.push(record);
        }), recordsToSubmit.length > 0 && submitRecords(recordsToSubmit);
    }
    function resetSelection() {
        $scope.state.selectedIndices = angular.copy(initialSelectedIndices);
    }
    var initialSelectedIndices = {
        NOT_SUBMITTED: {},
        SUBMITTED: {},
        DISAPPROVED: {}
    };
    $scope.state = {
        supervisors: [],
        iSelSup: -1,
        request: {
            supEmpGroup: !1,
            records: !1,
            recordSubmit: !1,
            emailReminder: !1
        },
        selectedIndices: angular.copy(initialSelectedIndices)
    }, $scope.state.request.supEmpGroup = !0, supEmpGroupService.init().then(initializeSupervisors).finally(function() {
        $scope.state.request.supEmpGroup = !1;
    }), $scope.$watch("state.iSelSup", getActiveRecordsForSelSup), $scope.getSelSupEntry = function() {
        return $scope.state.iSelSup < 0 ? null : $scope.state.supervisors[$scope.state.iSelSup];
    }, $scope.getRecords = function(status) {
        var supEntry = $scope.getSelSupEntry();
        return supEntry ? getRecords(supEntry, status) : null;
    }, $scope.hasRecords = function(status) {
        return ($scope.getRecords(status) || []).length > 0;
    }, $scope.selectAll = function(status) {
        for (var i = 0; i < $scope.getRecords(status).length; i++) $scope.state.selectedIndices[status][i] = !0;
    }, $scope.selectNone = function(status) {
        $scope.state.selectedIndices[status] = {};
    }, $scope.showDetails = function(record) {
        var params = {
            record: record
        };
        modals.open("record-details", params, !0);
    }, $scope.review = function(status, allowApproval) {
        var selectedRecords = getSelectedRecords(status), params = {
            records: selectedRecords,
            allowApproval: allowApproval
        };
        modals.open("record-review", params, !allowApproval).then(submitReviewedRecords);
    }, $scope.hasSelections = function(status) {
        for (var p in $scope.state.selectedIndices[status]) if ($scope.state.selectedIndices[status].hasOwnProperty(p) && $scope.state.selectedIndices[status][p] === !0) return !0;
        return !1;
    }, $scope.approveSelections = function() {
        var selectedRecords = getSelectedRecords("SUBMITTED");
        if (selectedRecords) {
            selectedRecords.forEach(function(record) {
                record.action = "submit";
            });
            var params = {
                approved: selectedRecords
            };
            return modals.open("record-approval-submit", params).then(function() {
                submitRecords(selectedRecords);
            });
        }
    }, $scope.remindSelections = function(status) {
        var selectedRecords = getSelectedRecords(status);
        modals.open("record-reminder-prompt", {
            records: selectedRecords
        }, !0).then(function() {
            return postReminders(selectedRecords);
        }).then(function() {
            modals.rejectAll(), modals.open("record-reminder-posted", !0);
        });
    }, $scope.resolveModal = modals.resolve;
}

function recordReviewModal(appProps, modals, locationService) {
    function link($scope, $elem, $attrs) {
        function selectNextPendingRecord() {
            for (var i = 0; i < $scope.records.length; i++) {
                var iAdj = (i + $scope.iSelectedRecord) % $scope.records.length;
                if ("untouched" === $scope.getApprovalStatus($scope.records[iAdj])) return $scope.iSelectedRecord = iAdj, 
                void locationService.scrollToId($scope.records[iAdj].timeRecordId);
            }
        }
        function selectNextRecord() {
            var nextIndex = $scope.iSelectedRecord + 1;
            nextIndex < $scope.records.length && ($scope.iSelectedRecord = nextIndex);
        }
        function selectPreviousRecord() {
            var previousIndex = $scope.iSelectedRecord - 1;
            previousIndex >= 0 && ($scope.iSelectedRecord = previousIndex);
        }
        function onKeydown(e) {
            if ([ 38, 39 ].indexOf(e.keyCode) >= 0) selectPreviousRecord(); else {
                if (!([ 40, 41 ].indexOf(e.keyCode) >= 0)) return;
                selectNextRecord();
            }
            $scope.$digest();
        }
        $scope.iSelectedRecord = 0, $scope.records = modals.params().records, $scope.allowApproval = modals.params().allowApproval;
        var approved = {}, disapproved = {};
        $elem.addClass("custom-fit"), $scope.submitChanges = function() {
            modals.open("record-approval-submit", {
                approved: approved,
                disapproved: disapproved
            }).then(function() {
                $scope.resolve();
            });
        }, $scope.resolve = function() {
            modals.resolve({
                approved: approved,
                disapproved: disapproved
            });
        }, $scope.close = function() {
            return $scope.submissionEmpty() ? void modals.reject() : void modals.open("record-review-close").then(modals.reject);
        }, $scope.cancelRecord = function() {
            var record = $scope.records[$scope.iSelectedRecord];
            delete approved[record.timeRecordId], delete disapproved[record.timeRecordId];
        }, $scope.approveRecord = function() {
            var record = $scope.records[$scope.iSelectedRecord];
            $scope.cancelRecord(), approved[record.timeRecordId] = record, selectNextPendingRecord();
        }, $scope.rejectRecord = function() {
            var record = $scope.records[$scope.iSelectedRecord];
            modals.open("record-review-reject", {
                record: record
            }, !0).then(function(reasons) {
                $scope.cancelRecord(record), record.rejectionRemarks = reasons, disapproved[record.timeRecordId] = record, 
                selectNextPendingRecord();
            });
        }, $scope.selectRecord = function(index) {
            $scope.iSelectedRecord = index;
        }, $scope.next = function() {
            selectNextPendingRecord();
        }, $scope.getApprovalStatus = function(record) {
            return record.timeRecordId in approved ? "approved" : record.timeRecordId in disapproved ? "disapproved" : "untouched";
        }, $scope.submissionEmpty = function() {
            return 0 === Object.keys(approved).length && 0 === Object.keys(disapproved).length;
        };
        var $doc = angular.element(document);
        $doc.on("keydown", onKeydown), $scope.$on("$destroy", function() {
            $doc.off("keydown", onKeydown);
        });
    }
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-review-modal",
        link: link
    };
}

function recordReviewRejectModal(modals, appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-reject-modal",
        link: function($scope, $elem, $attrs) {
            $scope.noRemarks = !1, $scope.cancel = modals.reject, $scope.submit = function() {
                "string" == typeof $scope.remarks && $scope.remarks.trim() ? modals.resolve($scope.remarks) : $scope.noRemarks = !0;
            };
        }
    };
}

function recordApproveSubmitModal(modals, appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-approve-submit-modal",
        link: function($scope, $elem, $attrs) {
            $scope.approved = modals.params().approved, $scope.approvedCount = $scope.approved ? Object.keys($scope.approved).length : 0, 
            $scope.disapproved = modals.params().disapproved, $scope.disapprovedCount = $scope.disapproved ? Object.keys($scope.disapproved).length : 0, 
            $scope.cancel = modals.reject, $scope.resolve = function() {
                modals.resolve();
            };
        }
    };
}

function recordReminderPromptModal(modals, appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/time/record/record-reminder-modal",
        link: function($scope, $elem, $attrs) {
            var params = modals.params();
            $scope.records = params.records, $scope.empIds = [], $scope.empIdRecordMap = {}, 
            $scope.records.forEach(function(record) {
                var empId = record.employeeId;
                $scope.empIds.indexOf(empId) === -1 && $scope.empIds.push(empId), $scope.empIdRecordMap.hasOwnProperty(empId) || ($scope.empIdRecordMap[empId] = []), 
                $scope.empIdRecordMap[empId].push(record);
            }), $scope.reject = modals.reject, $scope.resolve = modals.resolve;
        }
    };
}

function recordUtils() {
    function getTimeEntryFields() {
        return timeEntryFields.slice();
    }
    function getDailyTotal(entry) {
        return timeEntryFields.map(function(timeField) {
            var fieldValue = entry[timeField];
            return isNaN(fieldValue) ? 0 : +fieldValue;
        }).reduce(function(a, b) {
            return a + b;
        });
    }
    function calculateDailyTotals(record) {
        for (var i = 0, entries = record.timeEntries; i < entries.length; i++) entries[i].total = getDailyTotal(entries[i]);
    }
    function getTotal(record, type, payTypes) {
        var total = 0, entries = record.timeEntries;
        if (entries) for (var i = 0; i < entries.length; i++) (!payTypes || payTypes.indexOf(entries[i].payType) >= 0) && (total += +(entries[i][type] || 0));
        return total;
    }
    function getRecordTotals(record) {
        var totals = {};
        for (var iField in timeEntryFields) if (timeEntryFields.hasOwnProperty(iField)) {
            var field = timeEntryFields[iField];
            totals[field] = getTotal(record, field);
        }
        return totals.raSaWorkHours = getTotal(record, "workHours", [ "RA", "SA" ]), totals.tempWorkHours = getTotal(record, "workHours", [ "TE" ]), 
        totals.raSaTotal = getTotal(record, "total", [ "RA", "SA" ]), totals.total = getTotal(record, "total"), 
        totals;
    }
    function formatAttendRecord(attendRecord) {
        return attendRecord.totals = {
            workHours: attendRecord.workHours,
            holidayHours: attendRecord.holidayHours,
            vacationHours: attendRecord.vacationHours,
            personalHours: attendRecord.personalHours,
            sickEmpHours: attendRecord.sickEmpHours,
            sickFamHours: attendRecord.sickFamHours,
            miscHours: attendRecord.miscHours,
            total: attendRecord.totalHours
        }, attendRecord.recordStatus = "APPROVED_PERSONNEL", attendRecord.payPeriod = {
            payPeriodNum: attendRecord.payPeriodNum
        }, attendRecord;
    }
    function compareRecords(lhs, rhs) {
        var lhsBegin = moment(lhs.beginDate), rhsBegin = moment(rhs.beginDate);
        if (lhsBegin.isBefore(rhsBegin)) return -1;
        if (lhsBegin.isAfter(rhsBegin)) return 1;
        var lhsEnd = moment(lhs.endDate), rhsEnd = moment(rhs.endDate);
        return lhsEnd.isBefore(rhsEnd) ? -1 : lhsEnd.isAfter(rhsEnd) ? 1 : 0;
    }
    function entryHasEnteredtime(timeEntry) {
        for (var iField in timeEntryFields) if (timeEntryFields.hasOwnProperty(iField)) {
            var field = timeEntryFields[iField];
            if (!timeEntry.hasOwnProperty(field), !isNaN(parseInt(timeEntry[field]))) return !0;
        }
        return !1;
    }
    function recordHasEnteredTime(timeRecord) {
        var entries = timeRecord.timeEntries;
        for (var iEntry in entries) if (entries.hasOwnProperty(iEntry) && entryHasEnteredtime(entries[iEntry])) return !0;
        return !1;
    }
    function isFullTempRecord(timeRecord) {
        var entries = timeRecord.timeEntries;
        if (0 === entries.length) return !1;
        for (var iEntry in entries) if (entries.hasOwnProperty(iEntry)) {
            var entry = entries[iEntry];
            if ("TE" !== entry.payType) return !1;
        }
        return !0;
    }
    var timeEntryFields = [ "workHours", "travelHours", "holidayHours", "vacationHours", "personalHours", "sickEmpHours", "sickFamHours", "miscHours" ];
    return {
        getDailyTotal: getDailyTotal,
        calculateDailyTotals: calculateDailyTotals,
        getTotal: getTotal,
        getRecordTotals: getRecordTotals,
        getTimeEntryFields: getTimeEntryFields,
        formatAttendRecord: formatAttendRecord,
        compareRecords: compareRecords,
        entryHasEnteredTime: entryHasEnteredtime,
        recordHasEnteredTime: recordHasEnteredTime,
        isFullTempRecord: isFullTempRecord
    };
}

function recordValidatorDirective($timeout, $rootScope, debounce, activeRow) {
    return {
        restrict: "A",
        scope: {
            validateRecord: "&validate",
            record: "="
        },
        link: function($scope, $elem, $attrs) {
            function validate() {
                $scope.validateRecord(), $rootScope.$emit("validateRecordEntries");
            }
            var debounceDelay = 350, debouncedValidate = debounce(validate, debounceDelay);
            $scope.$watch("record.timeRecordId", function() {
                $timeout(function() {
                    $elem.children().each(function(index) {
                        function focusInCallBack(event) {
                            activeRow.setActiveRow(index), debouncedValidate();
                        }
                        function focusOutCallback(event) {
                            activeRow.setActiveRow(null), debouncedValidate();
                        }
                        var element = angular.element($elem.children()[index]);
                        element.on("focusin", focusInCallBack), element.on("focusout", focusOutCallback);
                    });
                });
            });
        }
    };
}

function entryValidatorDirective($timeout, $rootScope) {
    return {
        restrict: "A",
        scope: {
            validate: "&"
        },
        link: function($scope, $element, $attrs) {
            function validateEntry(event, args) {
                $scope.validate() ? $element.removeClass("invalid") : $element.addClass("invalid");
            }
            var deregisterValidateEntry = $rootScope.$on("validateRecordEntries", validateEntry);
            $scope.$on("$destroy", deregisterValidateEntry);
        }
    };
}

function activeTimeEntryRowService() {
    var activeRow = null;
    return {
        getActiveRow: function() {
            return activeRow;
        },
        setActiveRow: function(row) {
            activeRow = row;
        }
    };
}

angular.module("essTime").directive("accrualBar", [ "appProps", accrualBarDirective ]), 
angular.module("essTime").directive("accrualDetails", [ "appProps", "modals", "AccrualUtils", accrualDetailDirective ]), 
angular.module("essTime").directive("accrualHistory", [ "$timeout", "$rootScope", "appProps", "modals", "AccrualHistoryApi", "EmpInfoApi", "ActiveYearsTimeRecordsApi", accrualHistoryDirective ]);

var essTime = angular.module("essTime");

essTime.directive("accrualProjections", [ "$timeout", "$rootScope", "appProps", "AccrualHistoryApi", "EmpInfoApi", "modals", "AccrualUtils", accrualProjectionDirective ]), 
angular.module("essTime").service("AccrualUtils", accrualUtils), angular.module("essTime").directive("allowanceBar", [ "appProps", "AllowanceUtils", allowanceBarDirective ]), 
angular.module("essTime").directive("allowanceStatus", [ "appProps", "modals", "AllowanceApi", "AllowanceUtils", allowanceStatusDirective ]), 
angular.module("essTime").service("AllowanceUtils", [ "$filter", allowanceUtils ]);

var essTime = angular.module("essTime");

essTime.controller("GrantPrivilegesCtrl", [ "$scope", "$http", "appProps", "SupervisorChainApi", "SupervisorGrantsApi", "SupervisorOverridesApi", "modals", function($scope, $http, appProps, SupervisorChainApi, SupervisorGrantsApi, SupervisorOverridesApi, modals) {
    $scope.state = {
        empId: appProps.user.employeeId,
        selectedGrantee: null,
        grantees: null,
        granteeMap: null,
        granters: [],
        modified: !1,
        fetched: !1,
        saving: !1,
        saved: !1
    }, $scope.init = function() {
        $scope.state.selectedGrantee = null, $scope.state.grantees = [], $scope.state.granteeMap = {}, 
        $scope.state.granters = [], $scope.state.modified = $scope.state.fetched = $scope.state.saving = $scope.state.saved = !1, 
        SupervisorChainApi.get({
            empId: $scope.state.empId
        }, function(resp) {
            1 == resp.success && angular.forEach(resp.result.supChain, function(sup) {
                sup.granted = !1, sup.grantStart = sup.grantEnd = null, $scope.state.grantees.push(sup), 
                $scope.state.granteeMap[sup.employeeId] = sup;
            });
        }).$promise.then(function(resp) {
            return SupervisorGrantsApi.get({
                supId: $scope.state.empId
            }, function(resp) {
                resp.success && angular.forEach(resp.grants, function(grant) {
                    var supId = grant.granteeSupervisorId;
                    $scope.state.granteeMap[supId] || ($scope.state.grantees.push(grant.granteeSupervisor), 
                    $scope.state.granteeMap[supId] = grant.granteeSupervisor), $scope.state.granteeMap[supId].granted = !0, 
                    $scope.state.granteeMap[supId].grantStart = null != grant.startDate ? moment(grant.startDate).format("MM/DD/YYYY") : null, 
                    $scope.state.granteeMap[supId].grantEnd = null != grant.endDate ? moment(grant.endDate).format("MM/DD/YYYY") : null;
                });
            }).$promise;
        }).then(function(resp) {
            return SupervisorOverridesApi.get({
                supId: $scope.state.empId
            }, function(resp) {
                resp.success && ($scope.state.granters = resp.overrides.filter(function(ovr) {
                    return ovr.active;
                }).map(function(ovr) {
                    var granter = ovr.overrideSupervisor, startMoment = moment(ovr.startDate || 0), endMoment = moment(ovr.endDate || "3000-01-01");
                    return granter.grantStartStr = ovr.startDate ? startMoment.format("MM/DD/YYYY") : "No Start Date", 
                    granter.grantEndStr = ovr.endDate ? endMoment.format("MM/DD/YYYY") : "No End Date", 
                    granter.status = ovr.active ? "Active" : "Inactive", moment().isBefore(startMoment) ? granter.status = "Pending" : moment().isAfter(endMoment) ? granter.status = "Expired" : granter.status = "Active", 
                    granter;
                })), $scope.state.fetched = !0;
            }).$promise;
        }).catch(function(resp) {
            modals.open("500", {
                details: resp
            });
        });
    }, $scope.saveGrants = function() {
        if ($scope.state.modified === !0 && $scope.state.fetched === !0) {
            var modifiedGrantees = $scope.state.grantees.filter(function(grantee) {
                return grantee.modified === !0;
            }).map(function(grantee) {
                return $scope.createGrantSaveView(grantee);
            });
            $scope.state.saving = !0, SupervisorGrantsApi.save(modifiedGrantees, function(resp) {
                $scope.state.saving = !1, $scope.state.modified = !1, $scope.state.saved = !0;
            }, function(resp) {
                modals.open("500", {
                    details: resp
                });
            });
        }
    }, $scope.createGrantSaveView = function(grantee) {
        return {
            granteeSupervisorId: grantee.employeeId,
            active: grantee.granted,
            granterSupervisorId: $scope.state.empId,
            startDate: grantee.grantStart ? moment(grantee.grantStart).format("YYYY-MM-DD") : null,
            endDate: grantee.grantEnd ? moment(grantee.grantEnd).format("YYYY-MM-DD") : null
        };
    }, $scope.setStartDate = function(grantee) {
        $scope.state.modified = !0, grantee.modified = !0, grantee.grantStart ? grantee.grantStart = null : grantee.grantStart = moment().format("MM/DD/YYYY");
    }, $scope.setEndDate = function(grantee) {
        $scope.state.modified = !0, grantee.modified = !0, grantee.grantEnd ? grantee.grantEnd = null : grantee.grantEnd = moment().format("MM/DD/YYYY");
    }, $scope.setModified = function(grantee) {
        $scope.state.modified = !0, grantee.modified = !0;
    }, $scope.reset = function() {
        $scope.init();
    }, $scope.init();
} ]);

var essTime = angular.module("essTime");

essTime.controller("PayPeriodCalendarCtrl", [ "$scope", "$http", "PayPeriodApi", "HolidayApi", "modals", function($scope, $http, PayPeriodApi, HolidayApi, modals) {
    $scope.state = {
        year: moment().year(),
        currentDayMoment: moment().startOf("day")
    }, $scope.yearList = Array.apply(0, Array(10)).map(function(x, y) {
        return $scope.state.year + 2 - y - 1;
    }), $scope.months = [], $scope.periods = [], $scope.getPayPeriods = function(year, callback) {
        $scope.periodResp = PayPeriodApi.get({
            periodType: "AF",
            year: year
        }, function() {
            $scope.periods = $scope.periodResp.periods, $scope.periodMap = $scope.periods.reduce(function(res, curr) {
                return res[curr.endDate] = curr, res;
            }, {}), callback && callback();
        }, function(resp) {
            modals.open("500", {
                details: resp
            });
        });
    }, $scope.getHolidays = function(year, callback) {
        $scope.holidaysResp = HolidayApi.get({
            year: year
        }, function() {
            $scope.holidays = $scope.holidaysResp.holidays, $scope.holidayMap = $scope.holidays.reduce(function(res, curr) {
                return res[curr.date] = curr, res;
            }, {}), callback && callback();
        });
    }, $scope.generateMonths = function(year) {
        $scope.months = [];
        for (var i = 0; i < 12; i++) $scope.months.push(moment().year(year).month(i).format("M/D/YYYY"));
    }, $scope.$watch("state.year", function(year, oldYear) {
        $scope.getPayPeriods(year, function() {
            $scope.getHolidays(year, function() {
                $scope.generateMonths(year);
            });
        });
    }), $scope.periodHighlight = function() {
        return function(date) {
            var cssClasses = [], toolTips = [], mDate = moment(date).startOf("day"), mDateStr = mDate.format("YYYY-MM-DD");
            return mDate.isSame($scope.state.currentDayMoment) && cssClasses.push("current-date"), 
            6 == mDate.day() || 0 == mDate.day() ? cssClasses.push("weekend-date") : ($scope.holidayMap[mDateStr] && (toolTips.push($scope.holidayMap[mDateStr].name), 
            cssClasses.push("holiday-date")), $scope.periodMap[mDateStr] && !$scope.periodMap[mDateStr].endYearSplit && (toolTips.push("Last Day of Pay Period " + $scope.periodMap[mDateStr].payPeriodNum), 
            cssClasses.push("pay-period-end-date"))), [ !1, cssClasses.join(" "), toolTips.join(" \\ ") ];
        };
    };
} ]), angular.module("essTime").controller("EmployeeSearchCtrl", [ "$scope", "modals", "AllowanceUtils", "AccrualPeriodApi", "AllowanceApi", employeeSearchCtrl ]), 
angular.module("essTime").directive("employeeSearch", [ "$filter", "appProps", "modals", "ActiveEmployeeApi", "EmpInfoApi", employeeSearchDirective ]), 
angular.module("essTime").directive("employeeSelect", [ "appProps", "$filter", "supEmpGroupService", employeeSelectDirective ]), 
angular.module("essTime").factory("supEmpGroupService", [ "$filter", "appProps", "modals", "SupervisorEmployeesApi", supEmpGroupService ]), 
angular.module("essTime").filter("entryHours", [ entryHoursFilter ]).directive("timeRecordInput", [ timeRecordInputDirective ]).directive("recordDetails", [ "appProps", "modals", "AccrualPeriodApi", "AllowanceApi", "AllowanceUtils", recordDetailsDirective ]).directive("recordDetailModal", [ "modals", recordDetailModalDirective ]);

var essApp = angular.module("essTime").controller("RecordEntryController", [ "$scope", "$rootScope", "$filter", "$q", "$timeout", "appProps", "ActiveTimeRecordsApi", "TimeRecordApi", "AccrualPeriodApi", "AllowanceApi", "MiscLeaveGrantApi", "HolidayApi", "TimeRecordCreationApi", "activeTimeEntryRow", "RecordUtils", "LocationService", "modals", "promiseUtils", "AllowanceUtils", recordEntryCtrl ]);

angular.module("essTime").directive("recordPostSaveModal", [ "appProps", "modals", postSaveModal ]).directive("recordSubmitAckModal", [ "appProps", "modals", submitAckModal ]).directive("recordFutureEndConfModal", [ "appProps", "modals", futureEndDateConfModal ]).directive("recordExpectedHoursModal", [ "appProps", "modals", expectedHoursModal ]);

var essTime = angular.module("essTime");

essTime.filter("timeRecordStatus", [ "$sce", function($sce) {
    var statusDispMap = {
        NOT_SUBMITTED: [ "Not Submitted", "#444444" ],
        SUBMITTED: [ "Submitted", "#0e4e5a" ],
        DISAPPROVED: [ "Supervisor Disapproved", "#B90504" ],
        APPROVED: [ "Supervisor Approved", "#799933" ],
        DISAPPROVED_PERSONNEL: [ "Personnel Disapproved", "#B90504" ],
        SUBMITTED_PERSONNEL: [ "Submitted Personnel", "#808d0a" ],
        APPROVED_PERSONNEL: [ "Personnel Approved", "#799933" ]
    };
    return function(status, showColor) {
        var statusDisp = statusDispMap.hasOwnProperty(status) ? statusDispMap[status][0] : "Unknown Status", color = statusDispMap.hasOwnProperty(status) ? statusDispMap[status][1] : "red";
        return showColor ? $sce.trustAsHtml("<span style='color:" + color + "'>" + statusDisp + "</span>") : statusDisp;
    };
} ]), essTime.filter("miscLeave", [ "appProps", function(appProps) {
    var miscLeaveMap = {};
    return angular.forEach(appProps.miscLeaves, function(miscLeave) {
        miscLeaveMap[miscLeave.type] = miscLeave;
    }), function(miscLeave, defaultLabel) {
        return miscLeaveMap.hasOwnProperty(miscLeave) ? miscLeaveMap[miscLeave].shortName : miscLeave ? miscLeave + "?!" : defaultLabel ? defaultLabel : "--";
    };
} ]), essTime.filter("hoursDiffHighlighter", [ "$sce", function($sce) {
    return function(hours) {
        var color = "#0e4e5a", sign = "";
        return hours > 0 ? (color = "#09BB05", sign = "+") : hours < 0 && (color = "#BB0505"), 
        $sce.trustAsHtml('<span style="color:' + color + '">' + sign + hours + "</span>");
    };
} ]);

var essTime = angular.module("essTime");

essTime.controller("RecordHistoryCtrl", [ "$scope", "$q", "appProps", "ActiveYearsTimeRecordsApi", "TimeRecordApi", "AttendanceRecordApi", "modals", "RecordUtils", recordHistoryCtrl ]), 
angular.module("essTime").directive("recordHistory", [ "$q", "appProps", "modals", "RecordUtils", "ActiveYearsTimeRecordsApi", "TimeRecordApi", "AttendanceRecordApi", recordHistoryDirective ]);

var essApp = angular.module("ess");

essApp.controller("RecordManageCtrl", [ "$scope", "$q", "$filter", "appProps", "RecordUtils", "modals", "badgeService", "supEmpGroupService", "SupervisorTimeRecordsApi", "TimeRecordReviewApi", "TimeRecordReminderApi", recordManageCtrl ]), 
function() {
    function initializeSprite(name, imgSrc, posX, posY, rotation, scale) {
        var sprite = {
            name: name,
            img: new Image(),
            x: posX || 0,
            y: posY || 0,
            rotation: rotation || 0,
            scale: scale || 1
        };
        return sprite.img.src = imgSrc, sprites[name] = sprite, sprite;
    }
    function initializeBug(startX, startY, size, speed) {
        var name = bugConst.pfx + bugConst.idNo++, scale = bugConst.scale * (size || 1), rotation = 2 * Math.random() * Math.PI, bugSprite = initializeSprite(name, bugConst.img, startX, startY, rotation, scale);
        return bugSprite.speed = bugConst.speed * (speed || 1), bugs.push(bugSprite), bugSprite;
    }
    function initializeRandomBug() {
        var startX = Math.random() * width, startY = Math.random() * height;
        return initializeBug(startX, startY);
    }
    function imageLoaded(img) {
        return img.complete && img.naturalWidth > 0;
    }
    function getRequestAnimationFrameFn() {
        var w = window;
        return w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;
    }
    function drawRotatedImage(image, x, y, scale, angle) {
        ctx.save(), ctx.translate(x, y), ctx.rotate(angle);
        var scaledDim = {
            width: image.width * scale,
            height: image.height * scale
        };
        ctx.drawImage(image, -(scaledDim.width / 2), -(scaledDim.height / 2), scaledDim.width, scaledDim.height), 
        ctx.restore();
    }
    function renderSprite(sprite) {
        imageLoaded(sprite.img) && drawRotatedImage(sprite.img, sprite.x, sprite.y, sprite.scale, sprite.rotation);
    }
    function render() {
        ctx.clearRect(0, 0, width, height);
        for (var iSprite in sprites) sprites.hasOwnProperty(iSprite) && renderSprite(sprites[iSprite]);
    }
    function mouseOnBug(bug) {
        var hitboxMargin = 50, bugRadiusVect = {
            x: bug.img.width * bug.scale / 2,
            y: bug.img.height * bug.scale / 2
        }, bugRadius = getDistance(bugRadiusVect), distanceFromBug = getDistance(getMovementVector(bug, mouse));
        return distanceFromBug < bugRadius + hitboxMargin;
    }
    function getDistance(movementVector) {
        return Math.sqrt(Math.pow(movementVector.x, 2) + Math.pow(movementVector.y, 2));
    }
    function getDirectionVector(movementVector) {
        var dist = getDistance(movementVector);
        return {
            x: movementVector.x / dist,
            y: movementVector.y / dist
        };
    }
    function getMovementVector(p1, p2) {
        var mov = {
            x: p2.x - p1.x,
            y: p2.y - p1.y
        };
        return Math.abs(mov.x) > width / 2 && (mov.x = -1 * Math.sign(mov.x) * (width - Math.abs(mov.x))), 
        Math.abs(mov.y) > height / 2 && (mov.y = -1 * Math.sign(mov.y) * (height - Math.abs(mov.y))), 
        mov;
    }
    function adjustCoordinate(coord, span) {
        return coord < 0 ? span + coord % span : coord % span;
    }
    function moveSprite(sprite, direction, distance) {
        sprite.x = adjustCoordinate(sprite.x + direction.x * distance, width), sprite.y = adjustCoordinate(sprite.y + direction.y * distance, height);
        var offset = Math.PI / 2;
        sprite.rotation = offset + Math.atan2(direction.y, direction.x);
    }
    function updateBug(bug, modifier) {
        var movementVector = getMovementVector(mouse, bug), directionVector = getDirectionVector(movementVector), dist = getDistance(movementVector);
        dist < bugConst.sight && moveSprite(bug, directionVector, bug.speed * modifier);
    }
    function clickBug(bug) {
        initializeRandomBug();
    }
    function onMouseClick() {
        for (var iBug = 0; iBug < bugs.length; iBug++) {
            var bug = bugs[iBug];
            mouseOnBug(bug) && clickBug(bug);
        }
    }
    function update(modifier) {
        mouseClicked && (onMouseClick(), mouseClicked = !1);
        for (var iBug = 0; iBug < bugs.length; iBug++) updateBug(bugs[iBug], modifier);
    }
    function main() {
        var now = Date.now(), delta = now - then;
        then = now;
        var secondsDelta = delta / 1e3;
        update(secondsDelta), render(), requestAnimationFrame(main);
    }
    var ctxPath = "https://goo.gl", canvas = document.getElementById("dbug-canvas");
    if (canvas) {
        var ctx = canvas.getContext("2d"), requestAnimationFrame = getRequestAnimationFrameFn(), width = document.body.clientWidth, height = document.body.clientHeight, then = Date.now(), sprites = {}, bugConst = {
            pfx: "bug",
            idNo: 0,
            img: ctxPath + "/7p9rz3",
            scale: .1,
            speed: 500,
            sight: 300
        }, bugs = [];
        canvas.width = width, canvas.height = height;
        var mouse = {
            x: 0,
            y: 0
        };
        canvas.addEventListener("mousemove", function(e) {
            var rect = canvas.getBoundingClientRect();
            mouse = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        });
        var mouseClicked = !1;
        canvas.addEventListener("click", function(e) {
            mouseClicked = !0;
        }), initializeBug(width / 2, height / 2, 1, 1), main();
    }
}();

var essApp = angular.module("ess");

essApp.directive("recordReviewModal", [ "appProps", "modals", "LocationService", recordReviewModal ]), 
essApp.directive("recordReviewRejectModal", [ "modals", "appProps", recordReviewRejectModal ]), 
essApp.directive("recordApproveSubmitModal", [ "modals", "appProps", recordApproveSubmitModal ]), 
essApp.directive("recordReminderPromptModal", [ "modals", "appProps", recordReminderPromptModal ]);

var essTime = angular.module("essTime");

essTime.service("RecordUtils", recordUtils), angular.module("essTime").directive("recordValidator", [ "$timeout", "$rootScope", "debounce", "activeTimeEntryRow", recordValidatorDirective ]).directive("entryValidator", [ "$timeout", "$rootScope", entryValidatorDirective ]).service("activeTimeEntryRow", activeTimeEntryRowService);

var essApp = angular.module("ess");

essApp.directive("supervisorRecordList", [ "appProps", "modals", function(appProps, modals) {
    function link($scope, $elem, $attr) {
        $scope.showDetails = function(record) {
            var params = {
                record: record,
                employee: record.employee
            };
            modals.open("record-details", params, !0);
        }, $scope.toggleSelected = function(index) {
            return !!$scope.selectedIndices && $scope.setSelected(index, !$scope.selectedIndices[index]);
        }, $scope.setSelected = function(index, isSelected) {
            return !!$scope.selectedIndices && (isSelected ? ($scope.selectedIndices[index] = !0, 
            !0) : (delete $scope.selectedIndices[index], !1));
        }, $scope.toggleRecsForEmp = function(record) {
            var desiredState = null;
            $scope.selectedIndices && angular.forEach($scope.records, function(rec, i) {
                rec.employeeId === record.employeeId && (null === desiredState ? desiredState = $scope.toggleSelected(i) : $scope.setSelected(i, desiredState));
            });
        };
    }
    return {
        scope: {
            records: "=",
            selectedIndices: "=?"
        },
        templateUrl: appProps.ctxPath + "/template/time/record/supervisor-record-list",
        link: link
    };
} ]);

var essTime = angular.module("essTime");

essApp.controller("TimeMainCtrl", [ "$scope", "appProps", "LocationService", "badgeService", "modals", "SupervisorTimeRecordCountsApi", function($scope, appProps, locationService, badgeService, modals, SupervisorTimeRecordCountsApi) {
    $scope.initializePendingRecordsBadge = function() {
        var isoDateFmt = "YYYY-MM-DD", params = {
            supId: appProps.user.employeeId,
            status: "SUBMITTED",
            from: moment().subtract(1, "year").format(isoDateFmt),
            to: moment().add(1, "month").format(isoDateFmt)
        };
        SupervisorTimeRecordCountsApi.get(params, function(resp) {
            badgeService.setBadgeValue("pendingRecordCount", resp.result.count);
        });
    }, $scope.go = function(path, params) {
        locationService.go(path, !1, params);
    }, $scope.logout = function() {
        locationService.go("/logout", !0);
    }, $scope.log = function(stuff) {}, $scope.handleErrorResponse = function(resp) {
        modals.open("500", {
            details: resp
        });
    };
} ]);

var essTimeOff = angular.module("essTime");

essTimeOff.controller("NewRequestCtrl", [ "$scope", "$http", function($scope, $http) {
    $scope.vac = 21, $scope.sick = 482, $scope.personal = 34;
} ]);
//# sourceMappingURL=ess-time.min.js.map