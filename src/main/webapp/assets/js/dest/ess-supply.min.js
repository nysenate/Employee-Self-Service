/*! ess - v - 2017-07-06 */
function supplyItemApi($resource, appProps, modals) {
    function items() {
        return itemsApi.get().$promise.then(returnResult).catch(apiError);
    }
    function itemsForLoc(locId) {
        return itemsForLocApi.get({
            locId: locId
        }).$promise.then(returnResult).catch(apiError);
    }
    function returnResult(response) {
        return response.result;
    }
    function apiError(response) {
        modals.open("500", {
            action: "get valid order destinations",
            details: response
        });
    }
    var itemsApi = $resource(appProps.apiPath + "/supply/items.json"), itemsForLocApi = $resource(appProps.apiPath + "/supply/items/:locId.json", {
        locId: "@locId"
    });
    return {
        items: items,
        itemsForLoc: itemsForLoc
    };
}

function supplyItemHistoryCtrl($scope, $q, supplyUtils, requisitionApi, locationApi, itemApi, modals) {
    function isItemSelectedInFilter(lineItem) {
        return "All" === $scope.filters.item.selected || $scope.filters.item.selected === lineItem.item.commodityCode;
    }
    function updateResults(itemHistory) {
        $scope.result.map.has(itemHistory.key()) ? $scope.result.map.get(itemHistory.key()).add(itemHistory.requisitions[0], itemHistory.quantity) : $scope.result.map.set(itemHistory.key(), itemHistory);
    }
    function ItemHistory(commodityCode, locationCode, quantity, requisition) {
        this.commodityCode = commodityCode, this.locationCode = locationCode, this.quantity = quantity, 
        this.requisitions = [ requisition ], this.key = function() {
            return this.commodityCode + ":" + this.locationCode;
        }, this.add = function(req, qty) {
            this.requisitions.push(req), this.quantity += qty;
        };
    }
    const DATE_FORMAT = "MM/DD/YYYY";
    $scope.filters = {
        location: {
            values: [],
            selected: ""
        },
        item: {
            values: [],
            selected: "",
            codeToId: {}
        },
        date: {
            from: {},
            to: {}
        }
    }, $scope.result = {
        map: new Map(),
        array: []
    }, $scope.details = null, $scope.loading = !1;
    var init = function() {
        $scope.loading = !0, initFilters().then($scope.onFilterChange);
    }, initFilters = function() {
        $scope.filters.date.from = moment().subtract(1, "month").format(DATE_FORMAT), $scope.filters.date.to = moment().format(DATE_FORMAT);
        var locPromise = locationApi.get().$promise.then(initLocationFilter), itemPromise = itemApi.items().then(initItemFilter), promises = [];
        return promises.push(locPromise), promises.push(itemPromise), $q.all(promises);
    }, initLocationFilter = function(response) {
        response.result.forEach(function(loc) {
            $scope.filters.location.values.push(loc.locId);
        }), supplyUtils.alphabetizeByName($scope.filters.location.values), $scope.filters.location.values.unshift("All"), 
        $scope.filters.location.selected = $scope.filters.location.values[0];
    }, initItemFilter = function(items) {
        items.forEach(function(item) {
            $scope.filters.item.values.push(item.commodityCode), $scope.filters.item.codeToId[item.commodityCode] = item.id;
        }), $scope.filters.item.values = supplyUtils.alphabetizeByName($scope.filters.item.values), 
        $scope.filters.item.values.unshift("All"), $scope.filters.item.selected = $scope.filters.item.values[0];
    };
    $scope.onFilterChange = function() {
        $scope.loading = !0, $scope.result.map.clear(), getRequisitions().then(parseResults).then(sortResults).then(function() {
            $scope.loading = !1;
        });
    };
    var getRequisitions = function() {
        var params = {
            status: [ "APPROVED" ],
            from: moment($scope.filters.date.from, DATE_FORMAT).startOf("day").format(),
            to: moment($scope.filters.date.to, DATE_FORMAT).endOf("day").format(),
            limit: "ALL",
            location: $scope.filters.location.selected,
            itemId: $scope.filters.item.codeToId[$scope.filters.item.selected]
        };
        return requisitionApi.get(params).$promise.catch(function(error) {
            modals.open("500", {
                details: error
            });
        });
    }, parseResults = function(requisitionResponse) {
        var requisitions = requisitionResponse.result;
        requisitions.forEach(function(requisition) {
            requisition.lineItems.forEach(function(lineItem) {
                if (isItemSelectedInFilter(lineItem) && lineItem.quantity > 0) {
                    var itemHistory = new ItemHistory(lineItem.item.commodityCode, requisition.destination.locId, lineItem.quantity, requisition);
                    updateResults(itemHistory);
                }
            });
        }), $scope.result.array = Array.from($scope.result.map.values());
    }, sortResults = function() {
        $scope.result.array.sort(function(a, b) {
            var aCommodityCode = a.commodityCode, bCommodityCode = b.commodityCode, aLocCode = a.locationCode, bLocCode = b.locationCode;
            return aCommodityCode === bCommodityCode ? aLocCode < bLocCode ? -1 : aLocCode > bLocCode ? 1 : 0 : aCommodityCode < bCommodityCode ? -1 : 1;
        });
    };
    $scope.displayDetails = function(key) {
        $scope.details = key;
    }, $scope.getItemQuantity = function(requisition, commodityCode) {
        var qty = 0;
        return requisition.lineItems.forEach(function(li) {
            li.item.commodityCode === commodityCode && (qty = li.quantity);
        }), qty;
    }, $scope.openReqModal = function(requisition) {
        modals.open("requisition-modal", requisition, !0);
    }, init();
}

function supplyOrderHistoryCtrl($scope, appProps, locationService, empInfoApi, orderHistoryApi, paginationModel, modals) {
    function queryOrderHistory() {
        return getLoggedInEmployeeInfo().then(getRequisitions).then(setRequisitions).finally(doneLoading);
    }
    function getLoggedInEmployeeInfo() {
        var params = {
            empId: appProps.user.employeeId,
            detail: !0
        };
        return empInfoApi.get(params, function() {}, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        }).$promise;
    }
    function getRequisitions(employeeInfoResponse) {
        $scope.filter.status.indexOf("ALL") != -1 && ($scope.filter.status = angular.copy($scope.STATUSES.slice(1)));
        var params = {
            location: employeeInfoResponse.employee.empWorkLocation.locId,
            customerId: employeeInfoResponse.employee.employeeId,
            status: $scope.filter.status,
            from: moment($scope.filter.date.from, DATE_FORMAT).startOf("day").format(),
            to: moment($scope.filter.date.to, DATE_FORMAT).endOf("day").format(),
            limit: $scope.paginate.itemsPerPage,
            offset: $scope.paginate.getOffset()
        };
        return orderHistoryApi.get(params, function(response) {
            $scope.paginate.setTotalItems(response.total);
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        }).$promise;
    }
    function setRequisitions(orderHistoryResponse) {
        return $scope.requisitions = orderHistoryResponse.result, $scope.requisitions;
    }
    function doneLoading() {
        $scope.loading = !1;
    }
    var DATE_FORMAT = "MM/DD/YYYY";
    $scope.STATUSES = [ "ALL", "PENDING", "PROCESSING", "COMPLETED", "APPROVED", "REJECTED" ], 
    $scope.requisitions = [], $scope.paginate = angular.extend({}, paginationModel), 
    $scope.filter = {
        date: {
            from: moment().subtract(1, "month").format(DATE_FORMAT),
            to: moment().format(DATE_FORMAT)
        },
        status: []
    }, $scope.loading = !0, $scope.init = function() {
        $scope.paginate.itemsPerPage = 12, $scope.filter.status = angular.copy($scope.STATUSES.slice(1)), 
        queryOrderHistory();
    }, $scope.init(), $scope.updateRequisitions = function() {
        $scope.loading = !0, queryOrderHistory();
    }, $scope.viewRequisition = function(requisition) {
        locationService.go("/supply/requisition/requisition-view", !1, "requisition=" + requisition.requisitionId + "&fromPage=orderhistory");
    };
}

function supplyHistoryController($scope, supplyIssuersApi, requisitionApi, itemApi, locationService, locationApi, paginationModel, supplyUtils, modals) {
    function getUpdatedOrders() {
        var params = {
            status: [ "APPROVED", "REJECTED" ],
            from: moment($scope.filter.date.from, DATE_FORMAT).startOf("day").format(),
            to: moment($scope.filter.date.to, DATE_FORMAT).endOf("day").format(),
            limit: $scope.paginate.itemsPerPage,
            offset: $scope.paginate.getOffset(),
            location: $scope.selectedLocation,
            issuerId: $scope.issuerNameToID[$scope.selectedIssuer],
            itemId: $scope.filter.commodityCode.codeToId[$scope.filter.commodityCode.selected]
        };
        return requisitionApi.get(params, function(response) {
            $scope.shipments = response.result, $scope.paginate.setTotalItems(response.total);
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function initFilters() {
        locationApi.get().$promise.then(setLocations), supplyIssuersApi.get().$promise.then(setIssuers), 
        itemApi.items().then(setCommodityCodes);
    }
    function doneLoading() {
        $scope.loading = !1;
    }
    const DATE_FORMAT = "MM/DD/YYYY";
    $scope.paginate = angular.extend({}, paginationModel), $scope.loading = !0, $scope.shipments = null, 
    $scope.locations = [], $scope.selectedLocation = "All", $scope.selectedIssuer = null, 
    $scope.issuers = [], $scope.issuerNameToID = [], $scope.filter = {
        date: {
            from: moment().subtract(1, "month").format(DATE_FORMAT),
            to: moment().format(DATE_FORMAT)
        },
        commodityCode: {
            codes: [],
            selected: "All",
            codeToId: {}
        }
    }, $scope.init = function() {
        $scope.paginate.itemsPerPage = 12, getUpdatedOrders().$promise.then(initFilters).then(doneLoading);
    }, $scope.init();
    var setLocations = function(response) {
        response.result.forEach(function(e) {
            $scope.locations.push(e.locId);
        }), supplyUtils.alphabetizeByName($scope.locations), $scope.locations.unshift("All"), 
        $scope.selectedLocation = $scope.locations[0];
    }, setIssuers = function(response) {
        response.result.forEach(function(e) {
            $scope.issuers.push(e.fullName), $scope.issuerNameToID[e.fullName] = e.employeeId;
        }), $scope.issuers.unshift("All"), $scope.selectedIssuer = $scope.issuers[0];
    }, setCommodityCodes = function(response) {
        var items = supplyUtils.alphabetizeItemsByCommodityCode(response);
        items.forEach(function(e) {
            $scope.filter.commodityCode.codes.push(e.commodityCode), $scope.filter.commodityCode.codeToId[e.commodityCode] = e.id;
        }), $scope.filter.commodityCode.codes.unshift("All"), $scope.filter.commodityCode.selected = $scope.filter.commodityCode.codes[0];
    };
    $scope.onFilterChange = function() {
        $scope.loading = !0, $scope.paginate.reset(), getUpdatedOrders().$promise.then(doneLoading).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }, $scope.onPageChange = function() {
        $scope.loading = !0, getUpdatedOrders().$promise.then(doneLoading).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }, $scope.distinctItemQuantity = function(requisition) {
        return supplyUtils.countDistinctItemsInRequisition(requisition);
    }, $scope.viewRequisition = function(requisition) {
        modals.open("requisition-modal", requisition, !0);
    };
}

function itemAutocompleteService(itemsApi) {
    var items = [], commodityCodes = [], commodityCodesToItems = new Map(), setItems = function(response) {
        items = response;
    }, setCommodityCodes = function() {
        angular.forEach(items, function(item) {
            commodityCodes.push(item.commodityCode);
        });
    }, setCommodityCodesToItems = function() {
        angular.forEach(items, function(item) {
            commodityCodesToItems.set(item.commodityCode, item);
        });
    }, reset = function() {
        items = [], commodityCodes = [], commodityCodesToItems = new Map();
    };
    return {
        initWithAllItems: function() {
            return reset(), itemsApi.items().then(setItems).then(setCommodityCodes).then(setCommodityCodesToItems);
        },
        getItemFromCommodityCode: function(commodityCode) {
            return commodityCodesToItems.get(commodityCode);
        },
        getItemAutocompleteOptions: function() {
            var autocompleteOptions = {
                options: {
                    html: !0,
                    focusOpen: !1,
                    onlySelectValid: !0,
                    outHeight: 50,
                    minLength: 0,
                    source: function(request, response) {
                        var data = commodityCodes;
                        data = autocompleteOptions.methods.filter(data, request.term), data.length || data.push({
                            label: "Not Found",
                            value: ""
                        }), response(data);
                    },
                    messages: {
                        noResults: "",
                        results: function() {}
                    }
                },
                methods: {}
            };
            return autocompleteOptions;
        }
    };
}

function locationAutocompleteService(appProps, locationApi, destinationApi) {
    var locations = [], locationCodes = [], codeToLocMap = new Map(), setLocations = function(response) {
        locations = response.result;
    }, setCodes = function() {
        angular.forEach(locations, function(loc) {
            locationCodes.push(loc.code + " (" + loc.locationDescription + ")");
        }), sortCodes(locationCodes);
    }, sortCodes = function(codes) {
        codes.sort(function(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        });
    }, setCodesToLocationMap = function() {
        angular.forEach(locations, function(loc) {
            codeToLocMap.set(loc.code, loc);
        });
    }, reset = function() {
        locations = [], locationCodes = [], codeToLocMap = new Map();
    };
    return {
        initWithAllLocations: function() {
            return reset(), locationApi.get().$promise.then(setLocations).then(setCodes).then(setCodesToLocationMap);
        },
        initWithResponsibilityHeadLocations: function() {
            return reset(), destinationApi.get({
                empId: appProps.user.employeeId
            }).$promise.then(setLocations).then(setCodes).then(setCodesToLocationMap);
        },
        getCodes: function() {
            return locationCodes;
        },
        getCodeToLocationMap: function() {
            return codeToLocMap;
        },
        isValidCode: function(code) {
            return codeToLocMap.has(code);
        },
        getLocationFromCode: function(code) {
            return codeToLocMap.get(code);
        },
        getLocationAutocompleteOptions: function(height) {
            var autocompleteOptions = {
                options: {
                    html: !0,
                    focusOpen: !1,
                    onlySelectValid: !0,
                    outHeight: height || 300,
                    minLength: 0,
                    select: function(event, object) {
                        object.item.label = object.item.label.split("(")[0].trim(), object.item.value = object.item.value.split("(")[0].trim();
                    },
                    source: function(request, response) {
                        var data = locationCodes;
                        data = autocompleteOptions.methods.filter(data, request.term), data.length || data.push({
                            label: "Not Found",
                            value: ""
                        }), response(data);
                    },
                    messages: {
                        noResults: "",
                        results: function() {}
                    }
                },
                methods: {}
            };
            return autocompleteOptions;
        }
    };
}

function fulfillmentEditingModal($scope, appProps, modals, reqSaveApi, reqRejectApi, reqProcessApi, locationAutocompleteService, itemAutocompleteService) {
    function isOverPerOrderMax(lineItem) {
        return lineItem.quantity > lineItem.item.perOrderAllowance;
    }
    function containsSpecialItems(lineItem) {
        return lineItem.item.specialRequest;
    }
    function isOverPerMonthMax(lineItem) {
        if (null == $scope.locationStatistics) return !1;
        var monthToDateQty = $scope.locationStatistics.getQuantityForLocationAndItem($scope.originalRequisition.destination.locId, lineItem.item.commodityCode);
        return monthToDateQty > lineItem.item.perMonthAllowance;
    }
    function isItemADuplicate(newItem) {
        var duplicateItem = !1;
        return angular.forEach($scope.editableRequisition.lineItems, function(lineItem) {
            newItem.id === lineItem.item.id && (duplicateItem = !0);
        }), duplicateItem;
    }
    $scope.dirty = !1, $scope.originalRequisition = {}, $scope.editableRequisition = {}, 
    $scope.newLocationCode = "", $scope.newItemCommodityCode = "", $scope.deliveryMethods = [ "DELIVERY", "PICKUP" ], 
    $scope.displayRejectInstructions = !1, $scope.selfApprove = !1, $scope.init = function() {
        $scope.originalRequisition = modals.params(), $scope.originalRequisition.note = "", 
        $scope.editableRequisition = angular.copy($scope.originalRequisition), $scope.newLocationCode = $scope.editableRequisition.destination.code, 
        itemAutocompleteService.initWithAllItems(), appProps.user.employeeId === $scope.originalRequisition.customer.employeeId && ($scope.selfApprove = !0);
    }, $scope.init(), $scope.saveChanges = function() {
        modals.resolve(reqSaveApi.save({
            id: $scope.originalRequisition.requisitionId
        }, $scope.editableRequisition).$promise);
    }, $scope.processReq = function() {
        modals.resolve(reqProcessApi.save({
            id: $scope.originalRequisition.requisitionId
        }, $scope.editableRequisition).$promise);
    }, $scope.rejectReq = function() {
        modals.resolve(reqRejectApi.save({
            id: $scope.originalRequisition.requisitionId
        }, $scope.editableRequisition).$promise);
    }, $scope.closeModal = function() {
        modals.reject();
    }, $scope.approveShipment = function() {
        $scope.selfApprove || $scope.processReq();
    }, $scope.rejectOrder = function() {
        $scope.originalRequisition.note === $scope.editableRequisition.note ? $scope.displayRejectInstructions = !0 : $scope.rejectReq();
    }, $scope.onUpdate = function() {
        $scope.dirty = angular.toJson($scope.originalRequisition) !== angular.toJson($scope.editableRequisition);
    }, $scope.onLocationUpdated = function() {
        var loc = locationAutocompleteService.getLocationFromCode($scope.newLocationCode);
        loc ? $scope.editableRequisition.destination = loc : $scope.editableRequisition.destination = $scope.originalRequisition.destination, 
        $scope.onUpdate();
    }, $scope.getLocationAutocompleteOptions = function() {
        return locationAutocompleteService.getLocationAutocompleteOptions(100);
    }, $scope.calculateHighlighting = function(lineItem) {
        return {
            warn: isOverPerOrderMax(lineItem) || isOverPerMonthMax(lineItem) || containsSpecialItems(lineItem),
            bold: isOverPerMonthMax(lineItem)
        };
    }, $scope.highlightLineItem = function(lineItem) {
        return lineItem.quantity > lineItem.item.perMonthAllowance || lineItem.item.specialRequest;
    }, $scope.warning = !1, $scope.addItem = function() {
        $scope.warning = !1;
        var newItem = itemAutocompleteService.getItemFromCommodityCode($scope.newItemCommodityCode);
        return !!newItem && (isItemADuplicate(newItem) ? void ($scope.warning = !0) : ($scope.warning = !1, 
        $scope.editableRequisition.lineItems.push({
            item: newItem,
            quantity: 1
        }), $scope.newItemCommodityCode = "", void $scope.onUpdate()));
    }, $scope.resetCode = function() {
        $scope.warning = !1;
    }, $scope.getItemAutocompleteOptions = function() {
        return itemAutocompleteService.getItemAutocompleteOptions();
    };
}

function supplyFulfillmentController($scope, requisitionApi, supplyEmployeesApi, itemApi, modals, $interval, locationService, locationStatisticsService, supplyUtils, $q) {
    function updateShipments() {
        getPendingShipments(), getProcessingShipments(), getCompletedShipments(), getApprovedShipments(), 
        getSyncFailedShipments(), getCanceledShipments();
    }
    function getSupplyEmployees() {
        supplyEmployeesApi.get(function(response) {
            $scope.supplyEmployees = response.result;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getLocationStatistics() {
        var year = moment().year(), month = moment().month() + 1;
        locationStatisticsService.calculateLocationStatisticsFor(year, month).then(function(result) {
            $scope.locationStatistics = result;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getPendingShipments() {
        var params = {
            status: "PENDING",
            from: moment.unix(1).format()
        };
        return $scope.pendingSearch.response = requisitionApi.get(params), $scope.pendingSearch.response.$promise.then(function(response) {
            $scope.pendingSearch.matches = response.result, $scope.pendingSearch.error = !1;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getProcessingShipments() {
        var params = {
            status: "PROCESSING",
            from: moment.unix(1).format()
        };
        return $scope.processingSearch.response = requisitionApi.get(params), $scope.processingSearch.response.$promise.then(function(response) {
            $scope.processingSearch.matches = response.result, $scope.processingSearch.error = !1;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getCompletedShipments() {
        var params = {
            status: "COMPLETED",
            from: moment.unix(1).format()
        };
        return $scope.completedSearch.response = requisitionApi.get(params), $scope.completedSearch.response.$promise.then(function(response) {
            $scope.completedSearch.matches = response.result, $scope.completedSearch.error = !1;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getApprovedShipments() {
        var params = {
            status: "APPROVED",
            from: moment().startOf("day").format(),
            dateField: "approved_date_time"
        };
        return $scope.approvedSearch.response = requisitionApi.get(params), $scope.approvedSearch.response.$promise.then(function(response) {
            $scope.approvedSearch.matches = response.result, $scope.approvedSearch.error = !1;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getSyncFailedShipments() {
        var params = {
            from: moment.unix(1).format(),
            to: moment().startOf("day").format(),
            status: "APPROVED",
            dateField: "approved_date_time",
            savedInSfms: !1
        };
        return $scope.syncFailedSearch.response = requisitionApi.get(params), $scope.syncFailedSearch.response.$promise.then(function(response) {
            $scope.syncFailedSearch.matches = response.result, $scope.syncFailedSearch.matches = removeNewPlaceReq($scope.syncFailedSearch.matches), 
            $scope.syncFailedSearch.error = !1;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function removeNewPlaceReq(input) {
        var result = [];
        return input.forEach(function(ele) {
            null != ele.lastSfmsSyncDateTime && result.push(ele);
        }), result;
    }
    function getCanceledShipments() {
        var params = {
            status: "REJECTED",
            from: moment().startOf("day").format(),
            dateField: "rejected_date_time"
        };
        return $scope.canceledSearch.response = requisitionApi.get(params), $scope.canceledSearch.response.$promise.then(function(response) {
            $scope.canceledSearch.matches = response.result, $scope.canceledSearch.error = !1;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function isOverPerMonthMax(requisition) {
        if (null == $scope.locationStatistics) return !1;
        var isOverPerMonthMax = !1;
        return angular.forEach(requisition.lineItems, function(lineItem) {
            var monthToDateQty = $scope.locationStatistics.getQuantityForLocationAndItem(requisition.destination.locId, lineItem.item.commodityCode);
            monthToDateQty > lineItem.item.perMonthAllowance && (isOverPerMonthMax = !0);
        }), isOverPerMonthMax;
    }
    function successfulSave(response) {
        locationService.go("/supply/manage/fulfillment", !0);
    }
    function errorSaving(response) {
        if (void 0 !== response) return 409 === response.status ? $scope.saveResponse.error = !0 : modals.open("500", {
            details: response
        }), response;
    }
    function resetSearchParams() {
        locationService.setSearchParam(REQ_ID_SEARCH_PARAM, null);
    }
    function displayRequisitionWithId(requisitionId) {
        if (null != requisitionId) {
            var requisition = findRequisitionById(requisitionId);
            $scope.openRequisitionModal(requisition);
        }
    }
    function findRequisitionById(requisitionId) {
        for (var allReqs = $scope.pendingSearch.matches.concat($scope.processingSearch.matches, $scope.completedSearch.matches, $scope.approvedSearch.matches, $scope.syncFailedSearch.matches, $scope.canceledSearch.matches), i = 0; i < allReqs.length; i++) if (allReqs[i].requisitionId == requisitionId) return allReqs[i];
    }
    const REQ_ID_SEARCH_PARAM = "requisitionId";
    $scope.pendingSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.processingSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.completedSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.approvedSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.syncFailedSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.canceledSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.saveResponse = {
        response: {},
        error: !1
    }, $scope.supplyEmployees = [], $scope.locationStatistics = null;
    var intervalPromise = $interval(function() {
        updateShipments();
    }, 6e4);
    $scope.$on("$destroy", function() {
        $interval.cancel(intervalPromise);
    }), $scope.distinctItemQuantity = function(requisition) {
        return supplyUtils.countDistinctItemsInRequisition(requisition);
    }, $scope.calculateHighlighting = function(requisition) {
        return {
            warn: supplyUtils.containsItemOverOrderMax(requisition) || isOverPerMonthMax(requisition) || supplyUtils.containsSpecialItem(requisition),
            bold: isOverPerMonthMax(requisition)
        };
    }, $scope.openRequisitionModal = function(requisition) {
        if (null != requisition) {
            var status = requisition.status;
            "PENDING" === status || "PROCESSING" === status || "COMPLETED" === status ? $scope.saveResponse.response = modals.open("fulfillment-editing-modal", requisition).then(successfulSave).catch(errorSaving).finally(resetSearchParams) : modals.open("fulfillment-immutable-modal", requisition).finally(resetSearchParams);
        }
    }, $scope.setRequisitionSearchParam = function(requisitionId) {
        locationService.setSearchParam(REQ_ID_SEARCH_PARAM, requisitionId);
    }, $scope.$on("$locationChangeSuccess", function(event, newUrl) {
        newUrl.indexOf("supply/manage/fulfillment") !== -1 && displayRequisitionWithId(locationService.getSearchParam("requisitionId"));
    }), $scope.init = function() {
        var reqApiPromises = [];
        reqApiPromises.push(getPendingShipments()), reqApiPromises.push(getProcessingShipments()), 
        reqApiPromises.push(getCompletedShipments()), reqApiPromises.push(getApprovedShipments()), 
        reqApiPromises.push(getSyncFailedShipments()), reqApiPromises.push(getCanceledShipments()), 
        $q.all(reqApiPromises).then(function() {
            displayRequisitionWithId(locationService.getSearchParam(REQ_ID_SEARCH_PARAM));
        }), getSupplyEmployees(), getLocationStatistics();
    }, $scope.init();
}

function supplyReconciliationController($scope, requisitionApi, locationService, modals, $window, $timeout) {
    function initItems() {
        var params = {
            status: "APPROVED",
            from: moment().startOf("day").format(),
            to: moment().format(),
            dateField: "approved_date_time"
        };
        $scope.reconcilableSearch.response = requisitionApi.get(params, function(response) {
            $scope.reconcilableSearch.matches = response.result, $scope.reconcilableSearch.error = !1, 
            angular.forEach($scope.reconcilableSearch.matches, function(shipment) {
                angular.forEach(shipment.lineItems, function(lineItem) {
                    $scope.reconcilableItemMap.hasOwnProperty(lineItem.item.id) ? $scope.reconcilableItemMap[lineItem.item.id].push(shipment) : ($scope.reconcilableItemMap[lineItem.item.id] = [], 
                    $scope.reconcilableItemMap[lineItem.item.id].push(shipment), $scope.reconcilableSearch.items.push(lineItem.item));
                });
            });
        }, function(response) {
            $scope.reconcilableSearch.matches = [], $scope.reconcilableSearch.items = [], $scope.reconcilableSearch.error = !0, 
            modals.open("500", {
                details: response
            });
        });
    }
    $scope.selectedItem = null, $scope.viewItems = [], $scope.reconcilableSearch = {
        matches: [],
        items: [],
        response: {},
        error: !1
    }, $scope.currentPage = 1, $scope.reconcilableItemMap = {}, $scope.print = function() {
        $timeout($window.print, 0);
    }, $scope.setSelected = function(item) {
        $scope.selectedItem == item ? $scope.selectedItem = null : $scope.selectedItem = item;
    }, $scope.isItemSelected = function(item) {
        return $scope.selectedItem == item;
    }, $scope.getShipmentsWithItem = function(item) {
        return $scope.reconcilableItemMap[item.id];
    }, $scope.getOrderedQuantity = function(shipment, item) {
        for (var lineItems = shipment.lineItems, i = 0; i < lineItems.length; i++) if (lineItems[i].item.id === item.id) return lineItems[i].quantity;
    }, $scope.viewShipment = function(shipment) {
        locationService.go("/supply/requisition/requisition-view", !1, "requisition=" + shipment.requisitionId + "&fromPage=reconciliation");
    }, $scope.init = function() {
        initItems();
    }, $scope.setCurrentPage = function(page) {
        $scope.currentPage = page;
    }, $scope.init();
}

function supplyNavigationController($scope, locationService, categoryService, stateService) {
    function init() {
        $scope.state.subscribe($scope, stateChangeCallback);
    }
    function stateChangeCallback() {
        $scope.state.isShopping() ? $scope.categories = categoryService.getCategories() : $scope.categories = [];
    }
    $scope.state = stateService, $scope.categories = [], init(), $scope.$on("$locationChangeStart", function(event, newUrl, oldUrl) {
        $scope.state.isShopping() && categoryService.setSelectedCategories(locationService.getSearchParam("category") || []);
    }), $scope.onCategoryUpdated = function() {
        categoryService.updateUrlParam();
    }, $scope.clearSelections = function() {
        categoryService.clearSelections();
    };
}

function supplyViewController($scope, historyApi, locationService, $window, $timeout, supplyUtils, modals) {
    function generateVersions() {
        for (var k in $scope.shipment) $scope.shipment.hasOwnProperty(k) && $scope.requisitionHistory.versions.push($scope.shipment[k]);
    }
    function generateVersionNames() {
        for (var i = 0; i < $scope.requisitionHistory.versions.length; i++) 0 === i ? $scope.requisitionHistory.versions[i].name = "Original" : i === $scope.requisitionHistory.versions.length - 1 ? $scope.requisitionHistory.versions[i].name = "Current" : $scope.requisitionHistory.versions[i].name = i + 1;
    }
    $scope.requisitionResponse = {}, $scope.requisitionHistory = {
        versions: []
    }, $scope.selectedVersion = {}, $scope.shipemnt = {}, $scope.init = function() {
        var fromPage = locationService.getSearchParam("fromPage");
        highlightMenu(fromPage);
        var id = locationService.getSearchParam("requisition");
        $scope.requisitionResponse = historyApi.get({
            id: id
        }), $scope.requisitionResponse.$promise.then(extractShipment).then(printIfRequested).then(generateHistory).then(selectCurrentVersion).catch(shipmentResourceErrorHandler);
    };
    var highlightMenu = function(fromPage) {
        $(".sub-topic").removeClass("active"), $(".sub-topic").toArray().forEach(function(t) {
            t.textContent.toLowerCase().replace(/\s/g, "").indexOf(fromPage) != -1 && t.classList.add("active");
        });
    }, extractShipment = function(response) {
        $scope.shipment = response.result;
    }, printIfRequested = function() {
        var print = locationService.getSearchParam("print");
        "true" === print && $timeout(function() {
            $window.print();
        });
    }, generateHistory = function() {
        generateVersions(), generateVersionNames(), $scope.requisitionHistory.versions.reverse();
    }, selectCurrentVersion = function() {
        $scope.selectedVersion = $scope.requisitionHistory.versions[0];
    }, shipmentResourceErrorHandler = function(response) {
        modals.open("500", {
            details: response
        });
    };
    $scope.init(), $scope.sortSelectedVersionLineItems = function() {
        if ($scope.selectedVersion && $scope.selectedVersion.lineItems) return supplyUtils.alphabetizeLineItems($scope.selectedVersion.lineItems);
    }, $scope.displayIssuedDate = function(selectedVersion) {
        return "COMPLETED" === selectedVersion.status || "APPROVED" === selectedVersion.status;
    };
}

function supplyCategoryService(itemApi, destinationService, locationService) {
    function Category(name) {
        this.name = name, this.selected = !1;
    }
    function getCategories() {
        return null !== categories && 0 !== categories.length || initCategories(), categories;
    }
    function getSelectedCategories() {
        var selected = [];
        return angular.forEach(getCategories(), function(cat) {
            cat.selected === !0 && selected.push(cat);
        }), selected;
    }
    function getSelectedCategoryNames() {
        var names = [];
        return getSelectedCategories().forEach(function(category) {
            names.push(category.name);
        }), names;
    }
    function setSelectedCategories(names) {
        getCategories().forEach(function(category) {
            category.selected = names.indexOf(category.name) !== -1;
        }), updateUrlParam();
    }
    function clearSelections() {
        setSelectedCategories(""), updateUrlParam();
    }
    function updateUrlParam() {
        locationService.setSearchParam("category", getSelectedCategoryNames(), !0, !1);
    }
    function initCategories() {
        destinationService.isDestinationConfirmed() && itemApi.itemsForLoc(destinationService.getDestination().locId).then(function(items) {
            angular.forEach(items, function(item) {
                isDistinctCategory(item.category) && categories.push(new Category(item.category));
            }), categories.sort(function(a, b) {
                return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
            }), setSelectedCategories(locationService.getSearchParam("category") || []);
        });
    }
    function isDistinctCategory(name) {
        var cats = $.grep(categories, function(cat) {
            return cat.name === name;
        });
        return !cats.length > 0;
    }
    var categories = [];
    return {
        getCategories: getCategories,
        getSelectedCategories: getSelectedCategories,
        getSelectedCategoryNames: getSelectedCategoryNames,
        setSelectedCategories: setSelectedCategories,
        clearSelections: clearSelections,
        updateUrlParam: updateUrlParam
    };
}

function supplyLocationStatisticsService($q, locationStatisticsApi) {
    function LocationStatistics(locationStatistcsMap) {
        this.locationStatisticsMap = locationStatistcsMap, this.getQuantityForLocationAndItem = function(location, item) {
            if (locationStatistcsMap[location]) return locationStatistcsMap[location].itemQuantities[item];
        };
    }
    return {
        calculateLocationStatisticsFor: function(year, month) {
            return $q(function(resolve, reject) {
                var params = {
                    year: year,
                    month: month
                };
                locationStatisticsApi.get(params, function(response) {
                    resolve(new LocationStatistics(response.result.items));
                });
            });
        }
    };
}

function supplyCartController($scope, storageService, supplyCart, requisitionApi, destinationService, appProps, modals, locationService, supplyUtils) {
    var displayedLineItems = [];
    $scope.destinationCode = null, $scope.destinationDescription = "", $scope.specialInstructions = null, 
    $scope.init = function() {
        var destination = destinationService.getDestination();
        null != destination && ($scope.destinationCode = destination.code, $scope.destinationDescription = destination.locationDescription || ""), 
        supplyCart.initializeCart(), displayedLineItems = angular.copy(supplyCart.getLineItems()), 
        displayedLineItems = supplyUtils.alphabetizeLineItems(displayedLineItems), $scope.specialInstructions = supplyCart.getSpecialInstructions();
    }, $scope.init(), $scope.getLineItems = function() {
        var lineItems = [];
        return displayedLineItems.forEach(function(li) {
            li.quantity > 0 && lineItems.push(li);
        }), lineItems;
    }, $scope.saveSpecialInstructions = function() {
        supplyCart.setSpecialInstructions($scope.specialInstructions), supplyCart.save();
    };
    var submitOrder = function(deliveryMethod) {
        var params = {
            customerId: appProps.user.employeeId,
            lineItems: supplyCart.getCartItems(),
            destinationId: $scope.destinationCode + "-W",
            deliveryMethod: deliveryMethod,
            specialInstructions: $scope.specialInstructions
        };
        requisitionApi.save(params, function(response) {
            supplyCart.reset(), modals.open("supply-cart-checkout-modal", response);
        }, function(response) {
            modals.open("500", {
                action: "checkout cart",
                details: response
            });
        });
    };
    $scope.checkout = function() {
        modals.open("delivery-method-modal", {}, !0).then(function(deliveryMethod) {
            submitOrder(deliveryMethod);
        }).catch(function() {});
    }, $scope.emptyCart = function() {
        function reset() {
            supplyCart.reset(), locationService.go("/supply/shopping/order", !1);
        }
        modals.open("supply-cart-empty-modal").then(reset);
    }, $scope.displayLargeImage = function(item) {
        modals.open("large-item-image-modal", {
            item: item
        }, !0);
    }, $scope.closeModal = function() {
        modals.resolve();
    };
}

function cartService(storageService, lineItemService) {
    function addToCart(lineItem) {
        cart.set(lineItem.item.id, lineItem);
    }
    var KEY = "supply-cart", SPECIAL_INSTRUCTIONS_KEY = "supply-cart-special-instructions", cart = void 0, specialInstructions = void 0;
    return {
        initializeCart: function(lineItems) {
            return cart = new Map(), lineItems && lineItems.forEach(addToCart), this.load(), 
            cart;
        },
        updateCartLineItem: function(lineItem) {
            var li = angular.copy(lineItem);
            return cart.set(li.item.id, li), cart;
        },
        getLineItems: function() {
            var lineItems = [];
            return cart.forEach(function(lineItem, itemId) {
                lineItems.push(lineItem);
            }), lineItems;
        },
        getCartItems: function() {
            var lineItems = [];
            return cart.forEach(function(lineItem, itemId) {
                lineItem.quantity > 0 && lineItems.push(lineItem);
            }), lineItems;
        },
        isItemIdOrdered: function(itemId) {
            var lineItem = cart.get(itemId);
            return void 0 != lineItem && lineItem.quantity > 0;
        },
        getCartLineItem: function(itemId) {
            return this.isItemIdOrdered(itemId) ? cart.get(itemId) : null;
        },
        getSize: function() {
            var size = 0;
            return angular.forEach(cart, function(lineItem) {
                size += lineItem.quantity || 0;
            }), size;
        },
        isEmpty: function() {
            return 0 === this.getSize();
        },
        reset: function() {
            cart = new Map(), specialInstructions = void 0, this.save();
        },
        getSpecialInstructions: function() {
            return specialInstructions;
        },
        setSpecialInstructions: function(instructions) {
            specialInstructions = instructions;
        },
        save: function() {
            var lineItems = [];
            cart.forEach(function(lineItem, itemId) {
                lineItem.quantity > 0 && lineItems.push(lineItem);
            }), storageService.save(KEY, lineItems), storageService.save(SPECIAL_INSTRUCTIONS_KEY, specialInstructions);
        },
        load: function() {
            var lineItems = storageService.load(KEY);
            if (null != lineItems) {
                var functionalLineItems = [];
                lineItems.forEach(function(lineItem) {
                    functionalLineItems.push(lineItemService.createLineItem(lineItem.item, lineItem.quantity));
                }), functionalLineItems.forEach(addToCart);
            }
            specialInstructions = storageService.load(SPECIAL_INSTRUCTIONS_KEY) || null;
        }
    };
}

function largeItemImageModal() {
    return {
        template: '<div class="supply-item-image-modal"><div class="title-pane"><h3 ng-bind="item.description"></h3><div class="icon-cross modal-close-button" ng-click="rejectModal()"></div></div><img ng-src="{{imgUrl}}" err-src="{{errorUrl}}"></div>',
        controller: "LargeItemImageModalCtrl"
    };
}

function orderDestinationService(appProps, storageService, empInfoApi, locationAutocompleteService) {
    var KEY = "supply-destination", defaultCode = void 0;
    return {
        queryDefaultDestination: function() {
            if (!defaultCode) return empInfoApi.get({
                empId: appProps.user.employeeId,
                detail: !0
            }, function(response) {
                defaultCode = response.employee.empWorkLocation.code;
            }).$promise;
        },
        isDestinationConfirmed: function() {
            return null != storageService.load(KEY);
        },
        setDestination: function(code) {
            return !!locationAutocompleteService.isValidCode(code) && (storageService.save(KEY, locationAutocompleteService.getLocationFromCode(code)), 
            !0);
        },
        reset: function() {
            defaultCode = void 0, storageService.remove(KEY);
        },
        getDefaultCode: function() {
            return defaultCode;
        },
        getDestination: function() {
            return storageService.load(KEY);
        }
    };
}

function supplyOrderPageStateService($rootScope) {
    function notify() {
        $rootScope.$emit(EVENT);
    }
    var state, states = {
        LOADING: 0,
        SELECTING_DESTINATION: 5,
        SHOPPING: 10,
        INVALID: 15
    }, EVENT = "supply-order-page-state-change";
    return {
        subscribe: function(scope, callback) {
            var handler = $rootScope.$on(EVENT, callback);
            scope.$on("$destroy", handler);
        },
        isLoading: function() {
            return state === states.LOADING;
        },
        isSelectingDestination: function() {
            return state === states.SELECTING_DESTINATION;
        },
        isShopping: function() {
            return state === states.SHOPPING;
        },
        toLoading: function() {
            state = states.LOADING, notify();
        },
        toSelectingDestination: function() {
            state = states.SELECTING_DESTINATION, notify();
        },
        toShopping: function() {
            state = states.SHOPPING, notify();
        },
        toInvalid: function() {
            state = states.INVALID, notify();
        }
    };
}

function itemFilterService() {
    function filterLineItemsByCategories(lineItems, categories) {
        if (0 === categories.length) return lineItems;
        var filtered = [];
        return angular.forEach(lineItems, function(lineItem) {
            categories.indexOf(lineItem.item.category) !== -1 && filtered.push(lineItem);
        }), filtered;
    }
    function filterLineItemsBySearch(lineItems, searchTerm) {
        var filtered = [];
        return angular.forEach(lineItems, function(lineItem) {
            lineItem.item.description.indexOf(searchTerm.toUpperCase()) !== -1 && filtered.push(lineItem);
        }), filtered;
    }
    return {
        filterLineItems: function(lineItems, categories, searchTerm) {
            var filteredLineItems = angular.copy(lineItems);
            return void 0 !== categories && null !== categories && categories.length > 0 && (filteredLineItems = filterLineItemsByCategories(filteredLineItems, categories)), 
            void 0 !== searchTerm && null !== searchTerm && searchTerm.length > 0 && (filteredLineItems = filterLineItemsBySearch(filteredLineItems, searchTerm)), 
            filteredLineItems;
        }
    };
}

function supplyOrderController($scope, locationService, supplyCart, paginationModel, locationAutocompleteService, itemApi, destinationService, modals, lineItemService, itemFilterService, categoryService, stateService) {
    function loadSelectDestinationState() {
        locationAutocompleteService.initWithResponsibilityHeadLocations().then(destinationService.queryDefaultDestination).then(setDestinationCode).then(setToSelectingDestinationState).catch(loadDestinationsError);
    }
    function setDestinationCode() {
        $scope.destinationCode = destinationService.getDefaultCode();
    }
    function setToSelectingDestinationState() {
        $scope.state.toSelectingDestination();
    }
    function loadDestinationsError(response) {
        modals.open("500", {
            action: "get valid order destinations",
            details: response
        });
    }
    function loadShoppingState() {
        $scope.state.toLoading(), $scope.destinationCode = destinationService.getDestination().code, 
        itemApi.itemsForLoc(destinationService.getDestination().locId).then(initializeCart).then(sortAndFilterLineItems).then(setDestinationDescription).then(setToShoppingState);
    }
    function initializeCart(items) {
        supplyCart.initializeCart(lineItemService.generateLineItems(items));
    }
    function sortAndFilterLineItems() {
        $scope.displayedLineItems = itemFilterService.filterLineItems(supplyCart.getLineItems(), categoryService.getSelectedCategoryNames(), $scope.filter.searchTerm), 
        $scope.displayedLineItems = updateSort($scope.displayedLineItems);
    }
    function setToShoppingState() {
        $scope.state.toShopping();
    }
    function setDestinationDescription() {
        $scope.destinationDescription = destinationService.getDestination().locationDescription || "";
    }
    function updateFiltersFromUrlParams() {
        $scope.paginate.currPage = locationService.getSearchParam("page") || 1, locationService.setSearchParam("page", $scope.paginate.currPage, !0, !0);
    }
    function updateSort(lineItems) {
        var cur = locationService.getSearchParam("sortBy") || [];
        return 0 != cur.length && cur[0] == $scope.sortBy || locationService.setSearchParam("sortBy", $scope.sortBy, !0, !1), 
        $scope.sorting[$scope.sortBy] == $scope.sorting.Name ? lineItems.sort(function(a, b) {
            return a.item.description < b.item.description ? -1 : a.item.description > b.item.description ? 1 : 0;
        }) : $scope.sorting[$scope.sortBy] == $scope.sorting.Category && lineItems.sort(function(a, b) {
            return a.item.category < b.item.category ? -1 : a.item.category > b.item.category ? 1 : 0;
        }), lineItems;
    }
    $scope.state = stateService, $scope.sorting = {
        Name: 0,
        Category: 10
    }, $scope.sortBy = $scope.sorting.Alphabet, $scope.displaySorting = Object.getOwnPropertyNames($scope.sorting), 
    $scope.paginate = angular.extend({}, paginationModel), $scope.filter = {
        searchTerm: ""
    }, $scope.displayedLineItems = [], $scope.destinationCode = "", $scope.destinationDescription = "", 
    $scope.init = function() {
        $scope.state.toLoading(), $scope.paginate.itemsPerPage = 16, updateFiltersFromUrlParams(), 
        destinationService.isDestinationConfirmed() ? loadShoppingState() : loadSelectDestinationState();
    }, $scope.init(), $scope.$on("$destroy", function() {
        $scope.state.toInvalid();
    }), $scope.search = function() {
        sortAndFilterLineItems();
    }, $scope.reset = function() {
        $scope.filter.searchTerm = "", sortAndFilterLineItems();
    }, $scope.resetAllFilters = function() {
        categoryService.clearSelections(), $scope.reset();
    }, $scope.onPageChange = function() {
        locationService.setSearchParam("page", $scope.paginate.currPage, !0, !1);
    }, $scope.$on("$locationChangeSuccess", function(event, newUrl) {
        $scope.state.isShopping() && newUrl.indexOf("supply/shopping/order") != -1 && (updateFiltersFromUrlParams(), 
        sortAndFilterLineItems());
    }), $scope.confirmDestination = function() {
        var success = destinationService.setDestination($scope.destinationCode);
        success && loadShoppingState();
    }, $scope.getLocationAutocompleteOptions = function() {
        return locationAutocompleteService.getLocationAutocompleteOptions();
    }, $scope.resetDestination = function() {
        function reset() {
            $scope.state.toLoading(), supplyCart.reset(), destinationService.reset(), locationService.go("/supply/shopping/order", !0);
        }
        supplyCart.isEmpty() ? reset() : modals.open("order-canceling-modal").then(reset);
    }, $scope.displayLargeImage = function(item) {
        modals.open("large-item-image-modal", {
            item: item
        }, !0);
    };
}

function quantitySelectorCtrl($scope, modals, supplyCart) {
    function displayOrderMoreModal(lineItem) {
        modals.open("order-more-prompt-modal", {
            lineItem: lineItem
        }).then(updateAndSaveCart).catch(resetToOriginalQuantity);
    }
    function updateAndSaveCart(lineItem) {
        supplyCart.updateCartLineItem(lineItem), supplyCart.save();
    }
    function resetToOriginalQuantity(lineItem) {
        lineItem.quantity = supplyCart.getCartLineItem(lineItem.item.id).quantity;
    }
    function previousValueOverMaxQty(lineItem) {
        var savedLineItem = supplyCart.getCartLineItem(lineItem.item.id);
        return savedLineItem.quantity > savedLineItem.item.perOrderAllowance;
    }
    $scope.addToCart = function(lineItem) {
        !supplyCart.isItemIdOrdered(lineItem.item.id) && lineItem.item.specialRequest ? modals.open("special-order-item-modal", {
            lineItem: lineItem
        }).then(function() {
            lineItem.increment(), updateAndSaveCart(lineItem);
        }) : (lineItem.increment(), updateAndSaveCart(lineItem));
    }, $scope.decrementQuantity = function(lineItem) {
        lineItem.decrement(), updateAndSaveCart(lineItem);
    }, $scope.incrementQuantity = function(lineItem) {
        $scope.isAtMaxQty(lineItem) ? (lineItem.increment(), displayOrderMoreModal(lineItem)) : (lineItem.increment(), 
        updateAndSaveCart(lineItem));
    }, $scope.onCustomQtyEntered = function(lineItem) {
        lineItem.quantity = Number(lineItem.quantity), $scope.isOverMaxQty(lineItem) && !previousValueOverMaxQty(lineItem) ? displayOrderMoreModal(lineItem) : updateAndSaveCart(lineItem);
    }, $scope.isInCart = function(item) {
        return supplyCart.isItemIdOrdered(item.id);
    }, $scope.isAtMaxQty = function(lineItem) {
        return lineItem.quantity === lineItem.item.perOrderAllowance;
    }, $scope.isOverMaxQty = function(lineItem) {
        return lineItem.quantity > lineItem.item.perOrderAllowance;
    };
}

var essSupply = angular.module("essSupply");

essSupply.factory("SupplyItemApi", [ "$resource", "appProps", "modals", supplyItemApi ]);

var essSupply = angular.module("essSupply");

essSupply.directive("requisitionModal", [ "appProps", "modals", function(appProps, modals) {
    function link($scope, $elem, $attrs) {
        $scope.requisition = modals.params(), $scope.closeModal = function() {
            modals.reject();
        };
    }
    return {
        templateUrl: appProps.ctxPath + "template/supply/history/requisition-modal",
        link: link
    };
} ]), essSupply = angular.module("essSupply").controller("SupplyItemHistoryCtrl", [ "$scope", "$q", "SupplyUtils", "SupplyRequisitionApi", "LocationApi", "SupplyItemApi", "modals", supplyItemHistoryCtrl ]);

var essSupply = angular.module("essSupply").controller("SupplyOrderHistoryCtrl", [ "$scope", "appProps", "LocationService", "EmpInfoApi", "SupplyRequisitionOrderHistoryApi", "PaginationModel", "modals", supplyOrderHistoryCtrl ]);

essSupply = angular.module("essSupply").controller("SupplyHistoryController", [ "$scope", "SupplyIssuersApi", "SupplyRequisitionApi", "SupplyItemApi", "LocationService", "LocationApi", "PaginationModel", "SupplyUtils", "modals", supplyHistoryController ]), 
angular.module("essSupply").service("SupplyItemAutocompleteService", [ "SupplyItemApi", itemAutocompleteService ]), 
angular.module("essSupply").service("SupplyLocationAutocompleteService", [ "appProps", "LocationApi", "SupplyDestinationApi", locationAutocompleteService ]);

var essSupply = angular.module("essSupply").directive("fulfillmentEditingModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/manage/modal/fulfillment-editing-modal",
        scope: {
            supplyEmployees: "=",
            locationStatistics: "="
        },
        controller: "FulfillmentEditingModal",
        controllerAs: "ctrl"
    };
} ]).directive("editableOrderListing", [ "appProps", function(appProps) {
    return {
        restrict: "A",
        scope: !1,
        templateUrl: appProps.ctxPath + "/template/supply/manage/modal/editable-order-listing"
    };
} ]).controller("FulfillmentEditingModal", [ "$scope", "appProps", "modals", "SupplyRequisitionByIdApi", "SupplyRequisitionRejectApi", "SupplyRequisitionProcessApi", "SupplyLocationAutocompleteService", "SupplyItemAutocompleteService", fulfillmentEditingModal ]), essSupply = angular.module("essSupply");

essSupply.directive("fulfillmentImmutableModal", [ "appProps", "modals", "LocationService", function(appProps, modals, locationService) {
    function link($scope, $elem, $attrs) {
        $scope.requisition = modals.params(), $scope.status = modals.params().status, $scope.close = function() {
            modals.resolve();
        }, $scope.closeModal = function() {
            modals.reject();
        };
    }
    return {
        templateUrl: appProps.ctxPath + "/template/supply/manage/modal/fulfillment-immutable-modal",
        link: link
    };
} ]), essSupply = angular.module("essSupply").controller("SupplyFulfillmentController", [ "$scope", "SupplyRequisitionApi", "SupplyEmployeesApi", "SupplyItemApi", "modals", "$interval", "LocationService", "SupplyLocationStatisticsService", "SupplyUtils", "$q", supplyFulfillmentController ]), 
essSupply = angular.module("essSupply").controller("SupplyReconciliationController", [ "$scope", "SupplyRequisitionApi", "LocationService", "modals", "$window", "$timeout", supplyReconciliationController ]);

var essSupply = angular.module("essSupply").controller("SupplyNavigationController", [ "$scope", "LocationService", "SupplyCategoryService", "SupplyOrderPageStateService", supplyNavigationController ]);

essSupply = angular.module("essSupply").controller("SupplyViewController", [ "$scope", "SupplyRequisitionHistoryApi", "LocationService", "$window", "$timeout", "SupplyUtils", "modals", supplyViewController ]);

var essSupply = angular.module("essSupply");

essSupply.factory("SupplyCategoryService", [ "SupplyItemApi", "SupplyOrderDestinationService", "LocationService", supplyCategoryService ]);

var essSupply = angular.module("essSupply");

essSupply.service("SupplyInventoryService", [ "SupplyItemsApi", function(supplyItemsApi) {
    var items = [], promise = !1;
    return supplyItemsApi.get(function(response) {
        items = response.result, promise = !0;
    }), {
        promise: promise,
        getCopyOfItems: function() {
            return angular.copy(items);
        },
        orderQuantityRange: function(item) {
            for (var range = [], i = 1; i <= 2 * item.suggestedMaxQty; i++) range.push(i);
            return range;
        },
        getCartLineItem: function(id) {
            var item = !1, search = $.grep(items, function(prod) {
                return prod.id === id;
            });
            return search.length > 0 && (item = search[0]), item;
        }
    };
} ]);

var essSupply = angular.module("essSupply");

essSupply.service("SupplyLocationStatisticsService", [ "$q", "SupplyLocationStatisticsApi", supplyLocationStatisticsService ]), 
essSupply = angular.module("essSupply").controller("SupplyCartController", [ "$scope", "EssStorageService", "SupplyCartService", "SupplyRequisitionApi", "SupplyOrderDestinationService", "appProps", "modals", "LocationService", "SupplyUtils", supplyCartController ]);

var essSupply = angular.module("essSupply");

essSupply.directive("cartSummary", [ "appProps", function(appProps) {
    return {
        restrict: "E",
        controller: function($scope, SupplyCartService) {
            $scope.getSize = function() {
                return SupplyCartService.getSize();
            };
        },
        templateUrl: appProps.ctxPath + "/template/supply/shopping/cart/cart-summary",
        transclude: !0
    };
} ]);

var essSupply = angular.module("essSupply");

essSupply.directive("cartCheckoutModal", [ "appProps", function(appProps) {
    return {
        restrict: "E",
        templateUrl: appProps.ctxPath + "/template/supply/shopping/cart/cart-checkout-modal",
        controller: "CartCheckoutModalCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("CartCheckoutModalCtrl", [ "$scope", "modals", "LocationService", function($scope, modals, locationService) {
    $scope.requisitionId = modals.params().result.requisitionId, $scope.returnToSupply = function() {
        modals.resolve(), locationService.go("/supply/shopping/order", !1);
    }, $scope.logout = function() {
        locationService.go("/logout", !0);
    };
} ]), essSupply.directive("deliveryMethodModal", [ "appProps", function(appProps) {
    return {
        restrict: "E",
        templateUrl: appProps.ctxPath + "/template/supply/shopping/cart/delivery-method-modal",
        controller: "DeliveryMethodModalCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("DeliveryMethodModalCtrl", [ "$scope", "modals", function($scope, modals) {
    $scope.deliver = function() {
        modals.resolve("DELIVERY");
    }, $scope.pickup = function() {
        modals.resolve("PICKUP");
    };
} ]), essSupply.directive("supplyCartEmptyModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/shopping/cart/cart-empty-modal",
        controller: "SupplyCartEmptyModal",
        controllerAs: "ctrl"
    };
} ]).controller("SupplyCartEmptyModal", [ "$scope", "modals", "SupplyOrderDestinationService", "SupplyCartService", "LocationService", function($scope, modals, destinationService, supplyCart, locationService) {
    $scope.confirm = function() {
        modals.resolve();
    }, $scope.nevermind = function() {
        modals.reject();
    };
} ]);

var essSupply = angular.module("essSupply");

essSupply.service("SupplyCartService", [ "EssStorageService", "SupplyLineItemService", cartService ]);

var supply = angular.module("essSupply");

supply.directive("largeItemImageModal", [ largeItemImageModal ]), supply.controller("LargeItemImageModalCtrl", [ "$scope", "modals", "appProps", function($scope, modals, appProps) {
    $scope.item = modals.params().item, $scope.imgUrl = appProps.imageUrl + "/" + $scope.item.commodityCode + "_800.jpg", 
    $scope.errorUrl = appProps.imageUrl + "/no_photo_available.png", $scope.rejectModal = modals.reject;
} ]), angular.module("essSupply").directive("orderCancelingModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/shopping/order-canceling-modal",
        controller: "OrderCancelingCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("OrderCancelingCtrl", [ "$scope", "modals", "SupplyOrderDestinationService", "SupplyCartService", "LocationService", function($scope, modals, destinationService, supplyCart, locationService) {
    $scope.confirm = function() {
        modals.resolve();
    }, $scope.nevermind = function() {
        modals.reject();
    };
} ]), essSupply.service("SupplyOrderDestinationService", [ "appProps", "EssStorageService", "EmpInfoApi", "SupplyLocationAutocompleteService", orderDestinationService ]), 
angular.module("essSupply").directive("orderMorePromptModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/shopping/order-more-prompt-modal",
        controller: "OrderMorePromptModalCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("OrderMorePromptModalCtrl", [ "$scope", "modals", function($scope, modals) {
    $scope.confirm = function() {
        modals.resolve(modals.params().lineItem);
    }, $scope.nevermind = function() {
        modals.reject(modals.params().lineItem);
    };
} ]), angular.module("essSupply").factory("SupplyOrderPageStateService", [ "$rootScope", supplyOrderPageStateService ]);

var essSupply = angular.module("essSupply");

essSupply.directive("orderQuantityValidator", [ function() {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ngModel) {
            elm.bind("keydown", function(event) {
                8 !== event.keyCode && 9 !== event.keyCode && 116 !== event.keyCode && (event.keyCode >= 48 && event.keyCode <= 57 || event.keyCode >= 96 && event.keyCode <= 105 || event.preventDefault());
            });
        }
    };
} ]), angular.module("essSupply").directive("specialOrderItemModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/shopping/special-order-item-modal",
        controller: "SpecialOrderItemCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("SpecialOrderItemCtrl", [ "$scope", "modals", function($scope, modals) {
    $scope.cancel = function() {
        modals.reject();
    }, $scope.addToCart = function() {
        modals.resolve(modals.params().lineItem);
    };
} ]), angular.module("essSupply").service("SupplyItemFilterService", [ itemFilterService ]);

var essSupply = angular.module("essSupply");

essSupply.service("SupplyLineItemService", [ function() {
    function LineItem(item, qty) {
        this.MAX_QTY = 9999, this.item = item, this.quantity = qty, this.increment = function() {
            this.quantity < this.MAX_QTY && this.quantity++;
        }, this.decrement = function() {
            this.quantity > 0 && this.quantity--;
        };
    }
    return {
        generateLineItems: function(items) {
            var lineItems = [];
            return angular.forEach(items, function(item) {
                lineItems.push(new LineItem(item, 0));
            }), lineItems;
        },
        createLineItem: function(item, qty) {
            return new LineItem(item, qty);
        }
    };
} ]);

var essSupply = angular.module("essSupply").controller("SupplyOrderController", [ "$scope", "LocationService", "SupplyCartService", "PaginationModel", "SupplyLocationAutocompleteService", "SupplyItemApi", "SupplyOrderDestinationService", "modals", "SupplyLineItemService", "SupplyItemFilterService", "SupplyCategoryService", "SupplyOrderPageStateService", supplyOrderController ]);

essSupply.directive("destinationValidator", [ "SupplyLocationAutocompleteService", function(locationAutocompleteService) {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            ctrl.$validators.destination = function(modelValue, viewValue) {
                return locationAutocompleteService.isValidCode(modelValue) || 0 === modelValue.length;
            }, elm.on("autocompleteselect", function(a, object, e, c) {
                angular.element("form[name=selectDestinationForm]").scope().selectDestinationForm.destination.$error.destination = !1, 
                angular.element("form[name=selectDestinationForm]").scope().destinationCode || (angular.element("form[name=selectDestinationForm]").scope().destinationCode = object.item.label.split("(")[0].trim());
            });
        }
    };
} ]);

var essSupply = angular.module("essSupply").directive("supplyQuantitySelector", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/shopping/supply-quantity-selector",
        scope: {
            lineItem: "="
        },
        controller: "SupplyQuantitySelectorCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("SupplyQuantitySelectorCtrl", [ "$scope", "modals", "SupplyCartService", quantitySelectorCtrl ]);

essSupply = angular.module("essSupply"), essSupply.service("SupplyUtils", [ function() {
    return {
        alphabetizeLineItems: function(lineItems) {
            return lineItems.sort(function(a, b) {
                return a.item.description < b.item.description ? -1 : a.item.description > b.item.description ? 1 : 0;
            }), lineItems;
        },
        alphabetizeItemsByCommodityCode: function(items) {
            return items.sort(function(a, b) {
                return a.commodityCode < b.commodityCode ? -1 : a.commodityCode > b.commodityCode ? 1 : 0;
            }), items;
        },
        alphabetizeByName: function(names) {
            return names.sort(function(a, b) {
                return a < b ? -1 : a > b ? 1 : 0;
            }), names;
        },
        countDistinctItemsInRequisition: function(requisition) {
            var count = 0;
            return requisition.lineItems && angular.forEach(requisition.lineItems, function(item) {
                count++;
            }), count;
        },
        containsItemOverOrderMax: function(requisition) {
            var overOrderMax = !1;
            return angular.forEach(requisition.lineItems, function(lineItem) {
                lineItem.quantity > lineItem.item.perOrderAllowance && (overOrderMax = !0);
            }), overOrderMax;
        },
        containsSpecialItem: function(requisition) {
            var containsSpecialItems = !1;
            return angular.forEach(requisition.lineItems, function(lineItem) {
                lineItem.item.specialRequest && (containsSpecialItems = !0);
            }), containsSpecialItems;
        }
    };
} ]), essSupply.directive("capitalize", function($parse) {
    return {
        require: "ngModel",
        link: function(scope, element, attrs, modelCtrl) {
            var capitalize = function(inputValue) {
                void 0 === inputValue && (inputValue = ""), inputValue.indexOf("(") != -1 && (inputValue = inputValue.substring(0, inputValue.indexOf("(") - 1), 
                modelCtrl.$setViewValue(inputValue));
                var capitalized = inputValue.toUpperCase();
                return capitalized !== inputValue && (modelCtrl.$setViewValue(capitalized), modelCtrl.$render()), 
                capitalized;
            };
            modelCtrl.$parsers.push(capitalize), capitalize($parse(attrs.ngModel)(scope));
        }
    };
});
//# sourceMappingURL=ess-supply.min.js.map